<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Zack&#39;s Blog</title>
    <link>http://zackku.com/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Fri, 12 Apr 2019 05:54:43 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>Gradle的依赖方式——Lombok在Gradle中的正确配置姿势</title>
      <link>http://zackku.com/gradle-lombok-config/</link>
      <guid>http://zackku.com/gradle-lombok-config/</guid>
      <pubDate>Fri, 12 Apr 2019 05:54:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;写过java的都知道，lombok几乎在项目中处于不可或缺的一部分，但是lombok在Gradle的项目中配置并非人人都知道。&lt;/p&gt;
&lt;p&gt;很多人在项目依赖中直接这样写&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;compile &amp;quot;org.projectlombok:lombok:1.18.4&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但这样的处理在Gradle 5.0以上被命令禁止了，在4.x的高级版本中编译时也会有对应的告警&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;The following annotation processors were detected on the compile classpath: &amp;apos;lombok.launch.AnnotationProcessorHider$AnnotationProcessor&amp;apos; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Detecting annotation processors on the compile classpath is deprecated and Gradle 5.0 will ignore them.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Please add them to the annotation processor path instead. &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;If you did not intend to use annotation processors, &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;you can use the &amp;apos;-proc:none&amp;apos; compiler argument to ignore them.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>写过java的都知道，lombok几乎在项目中处于不可或缺的一部分，但是lombok在Gradle的项目中配置并非人人都知道。</p><p>很多人在项目依赖中直接这样写<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile &quot;org.projectlombok:lombok:1.18.4&quot;</span><br></pre></td></tr></table></figure></p><p>但这样的处理在Gradle 5.0以上被命令禁止了，在4.x的高级版本中编译时也会有对应的告警<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The following annotation processors were detected on the compile classpath: &apos;lombok.launch.AnnotationProcessorHider$AnnotationProcessor&apos; </span><br><span class="line">Detecting annotation processors on the compile classpath is deprecated and Gradle 5.0 will ignore them.</span><br><span class="line">Please add them to the annotation processor path instead. </span><br><span class="line">If you did not intend to use annotation processors, </span><br><span class="line">you can use the &apos;-proc:none&apos; compiler argument to ignore them.</span><br></pre></td></tr></table></figure></p><a id="more"></a><h1 id="Gradle的几种依赖方式"><a href="#Gradle的几种依赖方式" class="headerlink" title="Gradle的几种依赖方式"></a>Gradle的几种依赖方式</h1><p>下面先来了解下目前Gradle（4.1以上）的几种常见的依赖方式。</p><ul><li>api：与旧版的compile相同；</li><li>implementation：解决重复依赖问题。例如A依赖B，B依赖C，那么A里面将不能调用C的方法；</li><li>compile only：编译有效，打包无效。替代旧版的provider；</li><li>runtime only：打包有效，编译无效；</li><li>test、debug、release implementation：对应test、debug、release环境的implementation。</li></ul><p>回到Lombok的使用上，我们知道lombok是可以简化编写的代码，可以让开发人员通过注解的形式少写一些重复具有模板形式的代码。然后这些注解可以在代码编译的时候，自动生成对应模板代码。</p><p>并且在打jar/war包的时候，并不需要把lombok的依赖打进包中，所以Lombok在依赖上应该是compile only（仅在编译时生效）才对。</p><p>在Gradle 5.0环境下，我们尝试下改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly &quot;org.projectlombok:lombok:1.18.4&quot;</span><br></pre></td></tr></table></figure></p><p>然后执行gradle build。会发现代码报错，找不到对应生成后的代码（如果用idea build则不会，因为自带了插件。4.4+的版本也不会报错，但会告警）。</p><h1 id="Lombok的正确配置"><a href="#Lombok的正确配置" class="headerlink" title="Lombok的正确配置"></a>Lombok的正确配置</h1><p>回到开头的官方告警中，有这么一句<br><strong>Detecting annotation processors on the compile classpath is deprecated and Gradle 5.0 will ignore them.<br>Please add them to the annotation processor path instead. </strong></p><p>在5.0的环境下，注解处理将不再compile classpath中，需要手动添加到annotation processor path。</p><p>最终的对应依赖如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOnly &apos;org.projectlombok:lombok:1.18.4&apos;</span><br><span class="line">annotationProcessor &apos;org.projectlombok:lombok:1.18.4&apos;</span><br><span class="line">testCompileOnly &apos;org.projectlombok:lombok:1.18.4&apos;</span><br><span class="line">testAnnotationProcessor &apos;org.projectlombok:lombok:1.18.4&apos;</span><br></pre></td></tr></table></figure></p><p>P.S. 如果不配置compileOnly，只配annotationProcessor（gradle5.0以上才有），也会build成功，但会把依赖也打包进去。</p><p>针对5.0以下版本，对应依赖如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly &apos;org.projectlombok:lombok:1.18.4&apos;</span><br></pre></td></tr></table></figure></p><p>看完后，大家可以动起来，把自己项目中的lombok配置改掉吧（注意gradle版本）。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/gradle-lombok-config/#disqus_thread</comments>
    </item>
    
    <item>
      <title>都9102年了，还不会Docker？10分钟带你从入门操作到实战上手</title>
      <link>http://zackku.com/docker-in-act/</link>
      <guid>http://zackku.com/docker-in-act/</guid>
      <pubDate>Mon, 10 Dec 2018 08:44:02 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;Docker简述&quot;&gt;&lt;a href=&quot;#Docker简述&quot; class=&quot;headerlink&quot; title=&quot;Docker简述&quot;&gt;&lt;/a&gt;Docker简述&lt;/h1&gt;&lt;p&gt;Docker是一种OS虚拟化技术，是一个开源的应用容器引擎。它可以让开发者将应用打包到一个可移植的容器中，并且该容器可以运行在几乎所有linux系统中（Windows10目前也原生支持，Win10前需要内置虚拟机），正所谓“一次打包，到处运行”。&lt;/p&gt;
&lt;p&gt;Docker容器的运行是完全的沙箱机制，相互之间不会有任何关联（除非自己串联集群）。网络、存储、进程等资源，不仅对于不同的容器是相互隔离，对于宿主机和容器直接也是隔离的，除非你手动映射暴露端口或者挂载存储卷。&lt;/p&gt;
&lt;p&gt;很多人不理解，Docker和虚拟机到底有什么区别。&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/docker-in-act/architecture-vm-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="Docker简述"><a href="#Docker简述" class="headerlink" title="Docker简述"></a>Docker简述</h1><p>Docker是一种OS虚拟化技术，是一个开源的应用容器引擎。它可以让开发者将应用打包到一个可移植的容器中，并且该容器可以运行在几乎所有linux系统中（Windows10目前也原生支持，Win10前需要内置虚拟机），正所谓“一次打包，到处运行”。</p><p>Docker容器的运行是完全的沙箱机制，相互之间不会有任何关联（除非自己串联集群）。网络、存储、进程等资源，不仅对于不同的容器是相互隔离，对于宿主机和容器直接也是隔离的，除非你手动映射暴露端口或者挂载存储卷。</p><p>很多人不理解，Docker和虚拟机到底有什么区别。<br><img src="http://qiniu.zackku.com/image/docker-in-act/architecture-vm-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><a id="more"></a><br><img src="http://qiniu.zackku.com/image/docker-in-act/architecture-docker-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从这两张结构图来看，Docker比虚拟机少了一层虚拟机操作系统，Docker的应用直接Docker引擎上运行。由于虚拟机需要一层操作系统，所以会导致虚拟机的体积非常大，通常在几G到十几G之间。并且通常一个虚拟机上，不只一个应用，因此对于整体的虚拟集群管理并不太友好，比较难做到灵活分配。</p><p>而一个Docker镜像的体积大约在几十M到几百M之间，一般一个镜像只打包一个应用，由多个镜像组成一个完整的项目，并且镜像易于复制，可以跨平台运行，这样可以使项目的部署管理有更好的灵活性。所以Docker无论从资源消耗上、管理上、使用上都在虚拟机之上，因此我们又有何理由不使用这样的容器化技术呢？</p><p>对于容器化技术的学习，可谓是深如海。从基本的镜像、容器操作，到镜像的打包、容器的部署，再到企业生产级的容器集群管理技术（Docker官方的Swarm、Google的Kubernetes），如此多的内容，并不是所有人技术人员都能一朝学会。不过除了生产级别的集群管理技术有难度意外，其他内容从学习使用的角度来说，其实是非常简单的，况且K8s这种东西，对于普通开发来说也是很少能接触到。</p><p>说到这里，可能还有很多人觉得这个是公司层面、运维层面的操作，不是很了解Docker对于普通开发来说，意味着什么，对我们有什么好处？</p><ul><li>多办公环境，一键部署。假如你在公司一套开发环境，在家一套开发环境，当你公司的开发环境变更时，在家的环境就要跟着变，如果是使用Docker，将一些依赖型的应用，如Redis、ZK、Mysql等边缘服务都打包在docker里面。无论你在哪里改变了内容，只要在运行时更新下镜像，就可以按照最新的内容去执行了，不需要一个手动去安装，适配。</li><li>联调测试，无需依赖他人。当后端完成对外的接口后，将后端应用打包进docker，这样无论是前端、测试，在何地何时都可以自己把容器启动起来进行联调测试，而不需要自己手动一步步地搭建这个后端环境。</li><li>…</li></ul><p>下面就来一步步讲解下，普通开发所需要的Docker知识。</p><h1 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h1><p>学习Docker首先要了解下几个基础概念：</p><ul><li>宿主机，Host，运行Docker所在的物理机，是Docker运行的系统环境。</li><li>镜像，Image，相当于一个程序模板，通过这个模板可以生成很多个相似的容器。可以理解为Java中的类，它本身不具备执行运行的能力，是一个对象抽象的模板。每个镜像可以有多个版本，用tag来区分。镜像可以通过Dockerfile来构建。</li><li>容器，Container，Docker运行的最小单位对象。它是通过镜像实例化出来的一个可运行对象。容器的修改，可以提交反作用于镜像，更新这个容器的模板。</li><li>仓库，Repository，用于存储管理镜像的仓库，类似于git管理代码的仓库一样，可以管理多版本的镜像。</li></ul><p>镜像、容器、仓库的关系如下：<br><img src="http://qiniu.zackku.com/image/docker-in-act/lifecycle.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>一句话总结就是，从仓库中拉取镜像，利用镜像生成容器。</p><h1 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h1><p>了解完Docker的基本概念，我们开始来开始学习下入门操作。此处省略所有的Docker安装过程，自己去官网下载就行了，基本是傻瓜式安装。</p><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><p>通过<code>docker pull ${image_uri}:${image_tag}</code>命令，可以从远程仓库（默认是Docker Hub）中拉取所需要的镜像。</p><p>在<a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker Hub</a>的网站上可以搜索下自己需要的镜像以及版本。例如Ubuntu，上面提供了几个版本。<br><img src="http://qiniu.zackku.com/image/docker-in-act/ubuntu.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>我们拉一下<strong>16.04</strong>版本的ubuntu镜像。然后通过<code>docker images</code>命令，查看保存在本地镜像，发现多了一个ubuntu的镜像。<br><img src="http://qiniu.zackku.com/image/docker-in-act/ubuntu-image.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="容器创建、启动、停止、登入"><a href="#容器创建、启动、停止、登入" class="headerlink" title="容器创建、启动、停止、登入"></a>容器创建、启动、停止、登入</h2><p>有了镜像以后，就可以通过<code>docker run -it ${image_id}</code>创建启动一个容器了。</p><p><code>image_id</code>是镜像的id，通过<code>docker images</code>能查看到，也可以是镜像名(REPOSITORY:TAG)。</p><p><code>-it</code>可以让你在启动后，连上容器的终端。连上终端后，就可以在里面随意操作容器里面的内容了。<br><img src="http://qiniu.zackku.com/image/docker-in-act/run.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p><code>exit</code>退出容器后，容器就会自动停止了。但是这个容器依然还存在，只是”关机“了。（可以通过<code>ctrl+p,ctrl+q</code>，退出容器登入，而不关闭容器）</p><p>通过<code>docker ps -a</code>可以看到我们的容器已经<code>Exited</code>了。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-ps-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>通过<code>docker start ${container_id}</code>，我们把这个容器再次启动。通过<code>docker ps</code>(加上<em>-a</em>包含显示未启动的容器)，可以看到容器的状态为<em>UP</em>。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-start.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>同理，我们可以通过<code>docker stop ${container_id}</code>来停止容器，</p><p>在用<code>docker start</code>命令的时候，如果不加上<em>-a</em>参数，默认不会连接上容器的。不过我们可以在start后，通过<code>docker attach ${container_id}</code>来登入容器。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-attach.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>通过以上的基本操作，你基本可以利用docker当作一个虚拟机来使用了。如果想把容器和虚拟机的网络、存储打通，可以网上搜下了解下网络与卷挂载等容器设置。</p><h2 id="更新镜像"><a href="#更新镜像" class="headerlink" title="更新镜像"></a>更新镜像</h2><p>在上面的例子中，我们pull下来的仅仅是一个ubuntu的原始镜像，并没有过多的内容。下面我们在这个镜像的容器里面，安装一个jdk。<br><img src="http://qiniu.zackku.com/image/docker-in-act/jdk.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这样我们的容器里面就有一个jdk了，但是如果我们再用这个ubuntu原始镜像再创建一个容器，它是不会用这个jdk的。所以我们就需要把这个容器的内容，提交到镜像当中。</p><p>通过<code>docker commit ${container_id} ${repository}:${tag}</code>，在本地将容器内容提交到镜像当中。然后就可以拥有一个带jdk的ubuntu镜像了。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-commit.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>后面我们就可以利用这个镜像，生成带jdk的容器了。</p><p>以上的更新仅限于在本地的镜像，如果想把容器推送到云端就需要用<code>docker push</code>命令。前提是你已经登录了仓库拥有权限。</p><h2 id="镜像仓库"><a href="#镜像仓库" class="headerlink" title="镜像仓库"></a>镜像仓库</h2><p>上面提到，默认情况下，仓库是用Docker Hub。我们pull 和push都是在Docker hub上操作，但是如果镜像是内部私有使用的话，没有必要去使用Docker Hub，一个是网络慢，另一个是私有安全性问题。</p><p>针对以上问题，有两种解决方法，一个是自己搭建私有服务，另一个是用云服务的镜像管理平台（如阿里云的“容器镜像服务”）。前者对于一般开发者来说并没有必要，而且还要搞认证的，比较麻烦，这里不细说。下面介绍下如何用阿里云服务作为自己的私有仓库。</p><p>先在阿里云上创建一个镜像仓库，获得一个仓库地址，如<strong>registry.cn-shenzhen.aliyuncs.com/zackku/jdk</strong>。这里一个仓库地址，对应一种镜像（tag不同）。</p><p>利用<code>docker login</code>，先对阿里云的服务进行登录。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-login.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>然后对上面的jdk镜像打tag（其实也是改仓库源的过程）<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-tag.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>最后把镜像推送到阿里云就行了。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-push.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>推送后，就能在阿里云的仓库上看到这个镜像。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-ali.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>通过搭建私有仓库，我们就可以完全抛开宿主机的环境，构建好一个镜像，就可以到处运行了。</p><h1 id="Dockerfile构建镜像"><a href="#Dockerfile构建镜像" class="headerlink" title="Dockerfile构建镜像"></a>Dockerfile构建镜像</h1><p>从上面介绍，我们已经了解到，如何从拉取一个镜像、修改容器内容、提交镜像去构建一个我们所需要的镜像。但通过这些操作去构建一个镜像，一个是太繁琐，另一个问题是不清晰，没办法直观的了解镜像的构成。</p><p>Dockerfile就可以很好的解决该问题。它可以通过编写一个构建过程，来一站式构建镜像。下面同样以ubuntu为基础镜像，安装jdk构建一个新镜像为例，看看Dockerfile是怎么写的。<br><img src="http://qiniu.zackku.com/image/docker-in-act/dockerfile.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>然后执行<code>docker build -t registry.cn-shenzhen.aliyuncs.com/zackku/jdk2:1.0 .</code>就能把镜像构建出来了。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-build.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="Dockerfile高级技巧"><a href="#Dockerfile高级技巧" class="headerlink" title="Dockerfile高级技巧"></a>Dockerfile高级技巧</h2><p>上面是Dockerfile的基本使用，但实际情况下我们并不像（或者说不仅是）上面描述那样去构建镜像。下面介绍两个常用的使用原则。</p><p><strong>分层构建</strong>。其实Docker的镜像是分层结构的，看回之前推送到远端仓库的例子。<br><img src="http://qiniu.zackku.com/image/docker-in-act/fenceng.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>红框里面就是镜像一层层的提交，如果这层已经本地构建过了，下次不需要构建了，同理如果远端已经有这层了，也不需要推送这层。而且这种分层是可以在不同镜像间共享的，例如不同的Java项目都是依赖于JDK的运行环境，那么它们就可以共用JDK这层镜像内容。</p><p>所以，基于这样的特性，我们就应该要分层去构建镜像，抽象镜像共同点。具体操作的话，我们大致可以去分两次构建镜像，先构建一个base镜像，用于不同镜像的底层，例如Java项目的所有基础运行环境，然后再通过base镜像，构建develop表层的应用镜像。相当于把应用程序打包丢到develop层里面。并且这层要告诉Docker是怎么运行程序的。</p><p><strong>尽量构建小的base层</strong>。镜像的体积也是在使用Docker的时候要考虑的一个重要因素，因为如果镜像的体积过大，在更新镜像，拉取镜像的时候效率会低。尤其在刚刚所说的base层里面，如果base层做得太大太臃肿，里面程序过多，不仅仅体积大，还会让CPU、网络等资源消耗过大。其实我们在用Docker的时候，一般是一个容器只包含一个程序项目，关于这个程序的监控、健康等内容，在容器外通过k8s等集群管理去做，所以容器本身只需要保证自己的程序能够运行起来就行了。</p><p>至于上面我用ubuntu作为基础的操作系统是比较多余的，这里推荐只用apline操作系统作为程序的最底层镜像，它是一款轻型的Linux发行版，系统体积与运行时的资源消耗都相当低，十分适合用于Docker容器。基于apline的操作系统，我们在上面添加自己所需要的环境，例如安装一个Tomcat、JDK等，从而构建一个base的镜像。</p><p>上所说的base镜像，其实不太需要自己的写一层Dockfile，docker官方就直接提供了各种语言、环境的基础镜像，在github的<a href="https://github.com/docker-library" target="_blank" rel="noopener">docker-library</a>里面。如果再有自己的团队的运行环境的要求，可以在这个Dockerfile基础上去添加修改即可，或者再抽象多一层。</p><p>至于Dockfile怎么写，语法是什么，网上有大把详细的说明，由于篇幅问题，不在这里展开。</p><h1 id="docker-compose启动集群"><a href="#docker-compose启动集群" class="headerlink" title="docker-compose启动集群"></a>docker-compose启动集群</h1><p>前面已经介绍完一个单独的容器是如何构建与启动的了，但我们的项目往往不是只有一个容器的，把所有程序打包在一个容器不是正确的做法。所以我们怎么去管理启动这么多的容器，是一个必修的课题。在企业级的层面，有K8S，Swarm这种容器编排的管理工具，但稍微比较复杂，个人使用的话也没有太大必要。</p><p>这里推荐用Docker官方的docker-compose，它可以把所有的容器编排方式写在一个文件里，然后通过<code>docker-compose up</code>命令，就可以把一套的容器按照你的编排全部启动起来。<br><img src="http://qiniu.zackku.com/image/docker-in-act/docker-compose.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>在这个例子的<strong>services</strong>包含每个容器的配置，其中的redis、mongodb用的是默认的镜像、默认的配置，myproject是我们自己的项目。通过这样的编排，我们就能让我们的项目连上redis和mongodb。最后通过<code>docker-compose up</code>就会自动拉取镜像，按照编排跑起来了。</p><p>具体的语法也不赘述，关键就是容器的卷挂载，网络的配置，端口的暴露，容器的依赖关系。如果把这套东西用起来，慢慢自然就会了解，重要的是动手去做一遍，尝试一下。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/docker-in-act/#disqus_thread</comments>
    </item>
    
    <item>
      <title>“过时”的SpringMVC我们到底在用什么？深入分析DispatchServlet源码</title>
      <link>http://zackku.com/spring-mvc/</link>
      <guid>http://zackku.com/spring-mvc/</guid>
      <pubDate>Wed, 21 Nov 2018 09:54:27 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前已经分析过了Spring的IOC(&lt;a href=&quot;/spring-ioc&quot;&gt;《零基础带你看Spring源码——IOC控制反转》&lt;/a&gt;)与AOP(&lt;a href=&quot;/spring-aop&quot;&gt;《从源码入手，一文带你读懂Spring AOP面向切面编程》&lt;/a&gt;)的源码，本次就来分析下SpringMVC。本文先简述下目前SpringMVC的使用情况，然后通过Demo的简单让大家有一个初步的使用印象，然后带着印象去看其中执行的分发源码。&lt;/p&gt;
&lt;h1 id=&quot;到底什么是Spring-MVC，我们还在用吗？&quot;&gt;&lt;a href=&quot;#到底什么是Spring-MVC，我们还在用吗？&quot; class=&quot;headerlink&quot; title=&quot;到底什么是Spring MVC，我们还在用吗？&quot;&gt;&lt;/a&gt;到底什么是Spring MVC，我们还在用吗？&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;Spring MVC&lt;/strong&gt;，官方名字其实是&lt;strong&gt;Spring Web MVC&lt;/strong&gt;，Maven上的包名也是spring-webmvc。从Spring诞生以来，它就是一款基于Servlet Api的web架构。值得一提的是，在Spring5的时候，出了一款新的Web架构，Flux，是基于事件驱动模型（类似nodejs）做的。以后会写一篇来专门介绍一下Flux，敬请关注。&lt;/p&gt;
&lt;p&gt;MVC，可以说是“上个世纪”最流行的前后端交互模型。它包含Model（业务模型）、View（用户视图）、Controller（控制器），把各部分分开组织，对代码抽象与隔离的处理可谓是代码设计的典范。&lt;/p&gt;
&lt;p&gt;不过自从15年开始，随着各种前端框架的崛起，使得前端后端的关系发生进一步的演变，从MVC架构演变成前后端分离的REST架构了。以前MVC架构每次请求都需要经过控制器-&amp;gt;模型-&amp;gt;视图的流程，演变成前端请求后端接口，返回JSON的这样一种REST架构。&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-spring-mvc/mvc-rest.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前已经分析过了Spring的IOC(<a href="/spring-ioc">《零基础带你看Spring源码——IOC控制反转》</a>)与AOP(<a href="/spring-aop">《从源码入手，一文带你读懂Spring AOP面向切面编程》</a>)的源码，本次就来分析下SpringMVC。本文先简述下目前SpringMVC的使用情况，然后通过Demo的简单让大家有一个初步的使用印象，然后带着印象去看其中执行的分发源码。</p><h1 id="到底什么是Spring-MVC，我们还在用吗？"><a href="#到底什么是Spring-MVC，我们还在用吗？" class="headerlink" title="到底什么是Spring MVC，我们还在用吗？"></a>到底什么是Spring MVC，我们还在用吗？</h1><p><strong>Spring MVC</strong>，官方名字其实是<strong>Spring Web MVC</strong>，Maven上的包名也是spring-webmvc。从Spring诞生以来，它就是一款基于Servlet Api的web架构。值得一提的是，在Spring5的时候，出了一款新的Web架构，Flux，是基于事件驱动模型（类似nodejs）做的。以后会写一篇来专门介绍一下Flux，敬请关注。</p><p>MVC，可以说是“上个世纪”最流行的前后端交互模型。它包含Model（业务模型）、View（用户视图）、Controller（控制器），把各部分分开组织，对代码抽象与隔离的处理可谓是代码设计的典范。</p><p>不过自从15年开始，随着各种前端框架的崛起，使得前端后端的关系发生进一步的演变，从MVC架构演变成前后端分离的REST架构了。以前MVC架构每次请求都需要经过控制器-&gt;模型-&gt;视图的流程，演变成前端请求后端接口，返回JSON的这样一种REST架构。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/mvc-rest.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><a id="more"></a><br>问题来了，我们到底还在用SpringMVC吗？答案是，不全用。前后端做了代码以及部署的分离，也就是说后端并不感知前端的存在，所以对于后端而言，View（用户视图）也就无从可谈了。Model（业务模型）发送性质上的改变，以前是一个前端所需要的Model，给页面读取，现在是一个JSON格式给到前端，由前端自由处理。</p><p>而作为Web框架的核心，Controller（控制器）则是依然留存的。所以现在大家用SpringMVC用的更多是Controller这一层。当然SpringMVC还有其他组件，包括filter、Http Caching、Web Security等等。本文只是着重MVC架构中的Controller的功能，而Controller的核心组件则是DispatcherServlet。所以后面我们将通过Demo，来逐步深入了解下，DispatcherSevlet如何做到对请求控制分发的。</p><h1 id="传统SpringMVC启动简述"><a href="#传统SpringMVC启动简述" class="headerlink" title="传统SpringMVC启动简述"></a>传统SpringMVC启动简述</h1><p>在传统的SpringMVC中，需要配置web.xml和applicationContext.xml。前者是负责配置项目初始化的配置，如servlet、welcome页面等，是JavaEE的规范。后者是初始化Spring Context的配置，主要是Bean的配置。</p><p>前文说到，SpringMVC是基于Servlet的架构，而DispatcherServlet则是SpringMVC拦截处理所有请求的Servlet，所以web.xml需要配置DispatcherServlet。其他的还有contextLoaderListener，负责加载除DispatcherServlet外的所有context内容，另外还需要通过contextConfigLoader指定Spring的配置文件（如applicationContext.xml）。</p><p>那么在项目启动的时候，加载web.xml首先会执行contextLoaderListener，让它初始化好Spring的Application context。后面有HTTP请求进来，则会落到DispatcherServlet上，让它去做处理分发。</p><h1 id="SpringBoot-Web-Demo搭建"><a href="#SpringBoot-Web-Demo搭建" class="headerlink" title="SpringBoot Web Demo搭建"></a>SpringBoot Web Demo搭建</h1><p>自从Spring配置注解和SpringBoot诞生以来，越来越少人去写web.xml和applicationContext.xml配置文件了。但为了方便直接了解Dispatcher的原理，Demo直接用SpringBoot的starter一键式搭建。</p><p>直接添加web的starter依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.4.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><p>看下这个starter包含什么内容<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/starter.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>绿框是springMVC的依赖，红框是Spring自动配置的依赖，蓝框则是内嵌tomcat的依赖。里面Spring的版本是5.0.8 RELEASE的。</p><p>SpringBoot启动类<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/appliaction.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>测试controller<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/controller.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>启动项目后，在浏览器里面输入<code>http://localhost:8080/hello?name=Zack</code>。结果返回<code>Hello Zack</code>。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/test-demo.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>以上就是我们现在利用SpringMVC的基本内容，下面我们来看下SpringMVC如何利用DispatcherServlet做拦截分发的。</p><h1 id="DispatcherServlet源码分析"><a href="#DispatcherServlet源码分析" class="headerlink" title="DispatcherServlet源码分析"></a>DispatcherServlet源码分析</h1><p>当一个请求进来的时候，会先执行各种filter，过滤掉最终需要的请求，然后会落到DispatcherServlet中的<strong>doService()</strong>方法。该方法是预先设置一些特殊请求参数，然后再转发给<strong>doDispatch()</strong>做真正的处理转发。</p><p>看一下<strong>doDispatch()</strong>的注释说明<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/dispatcher-annotion.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>该方法的作用就是执行实际分发到的handler。</p><ul><li>Handler通过HandlerMapping的优先级获取。HandlerAdapter通过查询DispatcherServlet已装载的HandlerAdapter，并且支持该Handler而获取的。</li><li>所有的HTTP请求都是<strong>doDispatch()</strong>去处理的。具体是落到哪个方法去处理业务逻辑，取决于HandlerAdapters或者handlers。</li></ul><p>从注释可知，整个的分发逻辑核心，就在于HandlerAdapter和Handler。那这两到底是什么东西？</p><p>官网上的说明<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/handlerAdapter.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>HandlerAdapter协助DispatcherServlet去调用对应的handler，忽略具体handler是怎么调用的。例如调用注解形式的controller需要处理注解，xml配置形式的要解析配置文件。这个适配器就是为了帮助DispatcherServlet屏蔽掉处理具体的细节。</p><p>至于Handler没有清晰解释，但我们debug源码可以发现，Handler其实就是实际分配到具体需要去处理的方法(对比下图红框和上面Demo的controller)。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/handler.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>回到<strong>doDispatch()</strong>这个方法的源码上，看到<strong>getHandler()</strong>、<strong>getHandlerAdapter()</strong>就是获取Handler和HandlerAdapter所在。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/methods.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="getHandler"><a href="#getHandler" class="headerlink" title="getHandler()"></a>getHandler()</h2><p>看下<strong>getHandler()</strong>源码<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/getHandler.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>整个方法就那么几行，不过需要注意有两个点。一个是该方法是返回<strong>HandlerExecutionChain</strong>类型，而不是一个Handler。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/HandlerExecutionChain.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><strong>HandlerExecutionChain</strong>其实就是Handler的一层封装，还包含Handler对应的interceptor拦截器，用于执行Handler的一些前置和后置的操作。</p><p>另外一个点，<strong>HandlerExecutionChain</strong>是按顺序遍历<strong>handlerMappings</strong>拿出来的。那<strong>HandlerMapping</strong>又是什么呢？<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/handlerMapping-explanation.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从官网说明可知，它是一个请求和handler（实际是<strong>HandlerExecutionChain</strong>）的关联Map，通俗的说就是路由与处理逻辑的关联。它主要有两个实现，一个是<strong>RequestMappingHandlerMapping</strong>（支持注解形式方法），另一个是<strong>SimpleUrlHandlerMapping</strong>（维护显示注册的URI资源）。</p><p>由此可推测，在Spring启动的时候，就会去扫描注解、注册的静态资源，从而初始化这个<strong>handlerMappings</strong>。具体逻辑就在<strong>DispatcherServlet</strong>中的<strong>initHandlerMappings</strong>方法内。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/initHandlerMapping.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>初始化的方法内，主要有三步：</p><ol><li>从Spring的ApplicationContext中取出HandlerMapping的Bean</li><li>然后对上面取出来的Bean做优先级排序，主要对是@Order注解的排序</li><li>如果上面取不出Bean，则用默认策略。</li></ol><p>对于第三点的默认策略，可以找到<strong>DispatcherServlet.properties</strong>这个文件，里面配置了一些默认HandlerMapping、HandlerAdapter等相关类。</p><p>在初始化<strong>handlerMappings</strong>后，如果有请求进来，后面的request就用请求的路由与<strong>HandlerMapping</strong>对比，最后找出<strong>Handler</strong>（<strong>HandlerExecutionChain</strong>）。</p><h2 id="getHandlerAdapter"><a href="#getHandlerAdapter" class="headerlink" title="getHandlerAdapter()"></a>getHandlerAdapter()</h2><p>在取出实际处理的<strong>Handler</strong>后，就需要用它找出support它的适配器（<strong>HandlerAdapter</strong>）。按照前面对<strong>HandlerAdapter</strong>的描述，对于Demo而言，support这个<strong>Handler</strong>必定是<strong>RequestMappingHandlerAdapter</strong>。</p><p>这个逻辑也非常简单，同样是遍历已初始化的<strong>handlerAdapters</strong>（初始化的过程类似<strong>handlerMappings</strong>），然后对于具体每个<strong>handlerAdapter</strong>，调用其<strong>support()</strong>方法，看是否支持。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/getHandlerAdapter.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p><strong>supports()</strong>方法也很简单，就用instanceof判断handler是否Adapter自己支持的类。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/supports.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="HandlerAdapter-handle"><a href="#HandlerAdapter-handle" class="headerlink" title="HandlerAdapter.handle()"></a>HandlerAdapter.handle()</h2><p>在获取完<strong>Handler</strong>和<strong>HandlerAdapter</strong>后，就可以执行<strong>HandlerAdapter</strong>中的handle方法，其实际只是调用Handler的方法。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/ha-handle.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>我们按Demo例子，看下<strong>HttpRequestHandlerAdapter</strong>的<strong>handle()</strong>方法实现。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/handlemethod.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个方法里面就是用HttpServlet的Request和Reponse去调用我们自己写的controller里面的方法。需要注意的是，这个方法返回的是<strong>ModelAndView</strong>，但我们目前基于Rest架构是已经不用的了，所以方法返回<strong>null</strong>回去了。</p><h2 id="Handler的前置后置处理"><a href="#Handler的前置后置处理" class="headerlink" title="Handler的前置后置处理"></a>Handler的前置后置处理</h2><p>前面提到<strong>Handler</strong>是被封装在<strong>HandlerExecutionChain</strong>里面的，其中还包含一些前置后置的拦截器。所以在执行<strong>HandlerAdapter.handle()</strong>前后会有对<strong>HandlerExecutionChain</strong>的调用，执行<strong>interceptor</strong>对前后置处理的方法<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/interceptors.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>具体里面的实现就是执行<strong>interceptor</strong>的<strong>preHandle()</strong>和<strong>postHandle()</strong>方法。<br><img src="http://qiniu.zackku.com/image/java-spring-mvc/pre-post-handle.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>回过头来想下，这里的前后置处理会包括什么呢？在<strong>HandlerInterceptor</strong>注解上有说明三个实现类，分别是<strong>UserRoleAuthorizationInterceptor</strong>（检查用户权限）、<strong>LocaleChangeInterceptor</strong>（修改本地时间）、<strong>ThemeChangeInterceptor</strong>（修改当前主题）。可以看出<strong>HandlerInterceptor</strong>基本都是对请求的一些预处理和结果封装。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是SpringMVC中<strong>DispatcherServlet</strong>的基本过程。下面来总结下以上内容：</p><ol><li>前后端的架构演变导致SpringMVC的使用发生改变，更多着重在“C”上了。</li><li>“C”的核心在<strong>DispatcherServlet</strong>的<strong>doDispatcher()</strong>方法中。</li><li>利用request的路由，对比从已初始化的<strong>handlerMappings</strong>和<strong>handlerAdapters</strong>中获取<strong>handler</strong>和<strong>handlerAdapter</strong>。</li><li><strong>handler</strong>是封装在<strong>HandlerExecutionChain</strong>中，其中还包括<strong>handler</strong>的前后置拦截器。</li><li>最后利用适配器模式，调用<strong>HandlerAdapter.handle()</strong>方法去执行<strong>handler</strong>具体处理的业务逻辑。</li><li>在执行具体业务逻辑前后会执行封装在<strong>HandlerExecutionChain</strong>里面的拦截器。</li></ol><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/spring-mvc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>进阶的Redis之哈希分片原理与集群实战</title>
      <link>http://zackku.com/redis-cluster/</link>
      <guid>http://zackku.com/redis-cluster/</guid>
      <pubDate>Fri, 09 Nov 2018 03:32:06 GMT</pubDate>
      <description>
      
        &lt;p&gt;前面介绍了&lt;a href=&quot;/redis-rdb-aof&quot;&gt;《进阶的Redis之数据持久化RDB与AOF》&lt;/a&gt;和&lt;a href=&quot;/redis-sentinel&quot;&gt;《进阶的Redis之Sentinel原理及实战》&lt;/a&gt;，这次来了解下Redis的集群功能，以及其中哈希分片原理。&lt;/p&gt;
&lt;h1 id=&quot;集群分片模式&quot;&gt;&lt;a href=&quot;#集群分片模式&quot; class=&quot;headerlink&quot; title=&quot;集群分片模式&quot;&gt;&lt;/a&gt;集群分片模式&lt;/h1&gt;&lt;p&gt;如果Redis只用复制功能做主从，那么当数据量巨大的情况下，单机情况下可能已经承受不下一份数据，更不用说是主从都要各自保存一份完整的数据。在这种情况下，数据分片是一个非常好的解决办法。&lt;/p&gt;
&lt;p&gt;Redis的Cluster正是用于解决该问题。它主要提供两个功能：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动对数据分片，落到各个节点上&lt;/li&gt;
&lt;li&gt;即使集群部分节点失效或者连接不上，依然可以继续处理命令&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于第二点，它的功能有点类似于Sentienl的故障转移（可以了解下之前Sentinel的文章），在这里不细说。下面详细了解下Redis的槽位分片原理，在此之前，先了解下分布式简单哈希算法和一致性哈希算法，以帮助理解槽位的作用。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>前面介绍了<a href="/redis-rdb-aof">《进阶的Redis之数据持久化RDB与AOF》</a>和<a href="/redis-sentinel">《进阶的Redis之Sentinel原理及实战》</a>，这次来了解下Redis的集群功能，以及其中哈希分片原理。</p><h1 id="集群分片模式"><a href="#集群分片模式" class="headerlink" title="集群分片模式"></a>集群分片模式</h1><p>如果Redis只用复制功能做主从，那么当数据量巨大的情况下，单机情况下可能已经承受不下一份数据，更不用说是主从都要各自保存一份完整的数据。在这种情况下，数据分片是一个非常好的解决办法。</p><p>Redis的Cluster正是用于解决该问题。它主要提供两个功能：</p><ol><li>自动对数据分片，落到各个节点上</li><li>即使集群部分节点失效或者连接不上，依然可以继续处理命令</li></ol><p>对于第二点，它的功能有点类似于Sentienl的故障转移（可以了解下之前Sentinel的文章），在这里不细说。下面详细了解下Redis的槽位分片原理，在此之前，先了解下分布式简单哈希算法和一致性哈希算法，以帮助理解槽位的作用。<br><a id="more"></a></p><h2 id="简单哈希算法"><a href="#简单哈希算法" class="headerlink" title="简单哈希算法"></a>简单哈希算法</h2><p>假设有三台机，数据落在哪台机的算法为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = Hash(key) % 3</span><br></pre></td></tr></table></figure></p><p>例如key A的哈希值为4，4%3=1，则落在第二台机。Key ABC哈希值为11，11%3=2，则落在第三台机上。</p><p>利用这样的算法，假设现在数据量太大了，需要增加一台机器。A原本落在第二台上，现在根据算法4%4=0，落到了第一台机器上了，但是第一台机器上根本没有A的值。这样的算法会导致增加机器或减少机器的时候，引起大量的缓存穿透，造成雪崩。</p><h2 id="一致性哈希算法"><a href="#一致性哈希算法" class="headerlink" title="一致性哈希算法"></a>一致性哈希算法</h2><p>在1997年，麻省理工学院的Karger等人提出了<strong>一致性哈希算法</strong>，为的就是解决分布式缓存的问题。</p><p>在<strong>一致性哈希算法</strong>中，整个哈希空间是一个<strong>虚拟圆环</strong><br><img src="http://qiniu.zackku.com/image/redis-cluster/hash-1?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>假设有四个节点Node A、B、C、D，经过ip地址的哈希计算，它们的位置如下<br><img src="http://qiniu.zackku.com/image/redis-cluster/hash-2?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>有4个存储对象Object A、B、C、D，经过对Key的哈希计算后，它们的位置如下<br><img src="http://qiniu.zackku.com/image/redis-cluster/hash-3?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>对于各个Object，它所真正的存储位置是按顺时针找到的第一个存储节点。例如Object A顺时针找到的第一个节点是Node A，所以Node A负责存储Object A，Object B存储在Node B。</p><p>一致性哈希算法大概如此，那么它的<strong>容错性</strong>和<strong>扩展性</strong>如何呢？</p><p>假设Node C节点挂掉了，Object C的存储丢失，那么它顺时针找到的最新节点是Node D。也就是说Node C挂掉了，受影响仅仅包括Node B到Node C区间的数据，并且这些数据会转移到Node D进行存储。<br><img src="http://qiniu.zackku.com/image/redis-cluster/hash-4?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>同理，假设现在数据量大了，需要增加一台节点Node X。Node X的位置在Node B到Node C直接，那么受到影响的仅仅是Node B到Node X间的数据，它们要重新落到Node X上。</p><p>所以一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是<strong>数据倾斜</strong>。</p><p>如果在分片的集群中，节点太少，并且分布不均，一致性哈希算法就会出现部分节点数据太多，部分节点数据太少。也就是说无法控制节点存储数据的分配。如下图，大部分数据都在A上了，B的数据比较少。<br><img src="http://qiniu.zackku.com/image/redis-cluster/hash-5?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="哈希槽"><a href="#哈希槽" class="headerlink" title="哈希槽"></a>哈希槽</h2><p>Redis集群（Cluster）并没有选用上面一致性哈希，而是采用了<strong>哈希槽</strong>（SLOT）的这种概念。主要的原因就是上面所说的，一致性哈希算法对于数据分布、节点位置的控制并不是很友好。</p><p>首先<strong>哈希槽</strong>其实是两个概念，第一个是<strong>哈希算法</strong>。Redis Cluster的hash算法不是简单的hash()，而是crc16算法，一种校验算法。</p><p>另外一个就是<strong>槽位</strong>的概念，空间分配的规则。其实哈希槽的本质和一致性哈希算法非常相似，不同点就是对于哈希空间的定义。一致性哈希的空间是一个圆环，节点分布是基于圆环的，无法很好的控制数据分布。而Redis Cluster的槽位空间是自定义分配的，类似于Windows盘分区的概念。这种分区是可以自定义大小，自定义位置的。</p><p>Redis Cluster包含了16384个哈希槽，每个Key通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p><p>另外在<strong>容错性</strong>和<strong>扩展性</strong>上，表象与一致性哈希一样，都是对受影响的数据进行转移。而哈希槽本质上是对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。扩展节点也是一样，把其他节点上的槽位转移到新的节点上。</p><p><strong>但一定要注意的是，对于槽位的转移和分派，Redis集群是不会自动进行的，而是需要人工配置的。所以Redis集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。</strong></p><h1 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h1><p>下面以最简单的例子，抛开高可用主从复制级转移的内容，来重点介绍下Redis集群是如何搭建，槽位是如何分配的，以加深对Redis集群原理及概念的理解。</p><h2 id="redis-conf配置"><a href="#redis-conf配置" class="headerlink" title="redis.conf配置"></a>redis.conf配置</h2><p>先找到redis.conf，启用cluster功能。<br><img src="http://qiniu.zackku.com/image/redis-cluster/cluster-enabled.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p><code>cluster-enabled yes</code>默认是关闭的，要启用cluster，让redis成为集群的一部分，需要手动打开才行。</p><p>然后配置cluster的配置文件<br><img src="http://qiniu.zackku.com/image/redis-cluster/cluster-config-file.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>每一个cluster节点都有一个cluster的配置文件，这个文件主要用于记录节点信息，用程序自动生成和管理，不需要人工干预。唯一要注意的是，如果在同一台机器上运行多个节点，需要修改这个配置为不同的名字。</p><p>本次为了方便搭建，所有Redis实例都在同一台机器上，所以修改不同的cluster config名字后，复制三份redis.conf配置，以用于启动三个集群实例（cluster至少要三个主节点才能进行）。</p><h2 id="集群关联"><a href="#集群关联" class="headerlink" title="集群关联"></a>集群关联</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-server /usr/local/etc/redis/redis-6379.conf --port 6379 &amp;</span><br><span class="line">&gt; redis-server /usr/local/etc/redis/redis-6380.conf --port 6380 &amp;</span><br><span class="line">&gt; redis-server /usr/local/etc/redis/redis-6381.conf --port 6381 &amp;</span><br></pre></td></tr></table></figure><p>&amp;符号的作用是让命令在后台执行，但程序执行的log依然会打印在console中。也可以通过配置redis.conf中<code>deamonize yes</code>，让Redis在后台运行。</p><p>连上6379的Redis实例，然后通过<code>cluster nodes</code>查看集群范围。<br><img src="http://qiniu.zackku.com/image/redis-cluster/meet-before.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>连上其他实例也是一样，目前6379、6380、6381在各自的集群中，且集群只有它们自己一个。</p><p>在6379上，通过<code>cluster meet</code>命令，与6380、6381建立链接。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6380</span><br><span class="line">127.0.0.1:6379&gt; cluster meet 127.0.0.1 6381</span><br></pre></td></tr></table></figure></p><p><img src="http://qiniu.zackku.com/image/redis-cluster/meet-after.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>可以看到集群中已经包含了6379、6380、6381三个节点了。登录其他节点查看也是一样的结果。即使6380与6381之间没有直接手动关联，但在集群中，节点一旦发现有未关联的节点，会自动与之握手关联。</p><h2 id="槽位分配"><a href="#槽位分配" class="headerlink" title="槽位分配"></a>槽位分配</h2><p>通过<code>cluster info</code>命令查看集群的状态<br><img src="http://qiniu.zackku.com/image/redis-cluster/cluster-info.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>state的状态是fail的，还没启用。看下官方的说明<br><img src="http://qiniu.zackku.com/image/redis-cluster/slot-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>只有state为ok，节点才能接受请求。如果只要有一个槽位（slot）没有分配，那么这个状态就是fail。而一共需要分配16384槽位才能让集群正常工作。</p><p>接下来给6379分配0~5000的槽位，给6380分配5001~10000的槽位，给6381分配10001~16383的槽位。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; redis-cli -c -p 6379 cluster addslots &#123;0..5000&#125;</span><br><span class="line">&gt; redis-cli -c -p 6380 cluster addslots &#123;5001..10000&#125;</span><br><span class="line">&gt; redis-cli -c -p 6381 cluster addslots &#123;10001..16383&#125;</span><br></pre></td></tr></table></figure></p><p>再看看<code>cluster info</code><br><img src="http://qiniu.zackku.com/image/redis-cluster/info-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>state已经为ok，16384个槽位都已经分配好了。现在集群已经可以正常工作了。</p><h2 id="效果测试"><a href="#效果测试" class="headerlink" title="效果测试"></a>效果测试</h2><p>随便登上一个实例，记得加上参数<code>-c</code>，启用集群模式的客户端，否则无法正常运行。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -c -p 6380</span><br></pre></td></tr></table></figure></p><p>尝试下set、get操作<br><img src="http://qiniu.zackku.com/image/redis-cluster/get-set.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>可以看到，Redis集群会计算key落在哪个卡槽，然后会把命令转发到负责该卡槽的节点上执行。</p><p>利用<code>cluster keyslot</code>命令计算出key是在哪个槽位上，从而得出会跳转到哪个节点上执行。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/redis-cluster/#disqus_thread</comments>
    </item>
    
    <item>
      <title>进阶的Redis之数据持久化RDB与AOF</title>
      <link>http://zackku.com/redis-rdb-aof/</link>
      <guid>http://zackku.com/redis-rdb-aof/</guid>
      <pubDate>Fri, 02 Nov 2018 07:33:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;大家都知道，Redis之所以性能好，读写快，是因为Redis是一个内存数据库，它的操作都几乎基于内存。但是内存型数据库有一个很大的弊端，就是当数据库进程崩溃或系统重启的时候，如果内存数据不保存的话，里面的数据就会丢失不见了。这样的数据库并不是一个可靠的数据库。&lt;/p&gt;
&lt;p&gt;所以数据的持久化是内存型数据库的重中之重。它不仅提供数据保存硬盘的功能，还可以借此用硬盘容量扩展数据存储空间，使得Redis的可以存储超过机器本身内存大小的数据。&lt;/p&gt;
&lt;p&gt;Redis对于数据持久化提供了两种持久化的方案，RDB与AOF。它们的原理和使用场景都大不相同，下面我们来详细地了解下。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>大家都知道，Redis之所以性能好，读写快，是因为Redis是一个内存数据库，它的操作都几乎基于内存。但是内存型数据库有一个很大的弊端，就是当数据库进程崩溃或系统重启的时候，如果内存数据不保存的话，里面的数据就会丢失不见了。这样的数据库并不是一个可靠的数据库。</p><p>所以数据的持久化是内存型数据库的重中之重。它不仅提供数据保存硬盘的功能，还可以借此用硬盘容量扩展数据存储空间，使得Redis的可以存储超过机器本身内存大小的数据。</p><p>Redis对于数据持久化提供了两种持久化的方案，RDB与AOF。它们的原理和使用场景都大不相同，下面我们来详细地了解下。<br><a id="more"></a></p><h1 id="RDB——数据快照（Snapshot）"><a href="#RDB——数据快照（Snapshot）" class="headerlink" title="RDB——数据快照（Snapshot）"></a>RDB——数据快照（Snapshot）</h1><p>RDB，提供一个某个时间点的数据的Snapshot，保存在RDB文件中。它可以通过<code>SAVE/BGSAVE</code>命令手动执行，把数据Snapshot写到RDB文件，也可以通过配置，定时执行。</p><p>Redis也可以通过加载RDB文件，把数据从磁盘加载读取到Redis中。</p><h2 id="RDB文件创建"><a href="#RDB文件创建" class="headerlink" title="RDB文件创建"></a>RDB文件创建</h2><p>连上Redis，设值一些值，然后执行<code>SAVE</code>命令。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/set-value-save.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>然后可以查看下redis.conf的持久化工作目录。进入目录可以看到保存了一个dump.rdb文件。该文件是一个二进制文件，无法直接正常打开。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/save-rdb.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>至于<code>SAVE/BGSAVE</code>的区别，就是前置是阻塞执行，此时服务不会接受请求，后者是Fork一个子进程出来，由该进程去执行保存RDB文件的操作，不影响用户请求。</p><p>P.S. Redis是单进程的，所以<code>BGSAVE</code>只能Fork一个子进程，而不是创建一个线程处理。</p><p>以上是手动执行的过程。但在生产我们很少会手动登上服务去执行操作，所以更多的时候是依赖Redis的配置，定时保存RDB文件。</p><p>打开<code>redis.conf</code>配置文件，找到<strong>SNAPSHOTTING</strong>的配置，Save Point的设置。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/db-conf.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>图中的配置意思是，当至少有一个key变更时，900秒后会执行一次SAVE。其他配置同理，有10次变更，300秒后保存一次…..</p><p>在Redis中，这个自动保存RDB的功能是默认开启的。</p><h2 id="RDB文件加载"><a href="#RDB文件加载" class="headerlink" title="RDB文件加载"></a>RDB文件加载</h2><p>先kill掉Redis进程，再重新启动Redis Server，会发现日志会有这样的一行，<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/redis-load-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>并且Redis中，依然有之前设置的三个值。说明Redis在启动的时候，会加载数据初始化。</p><p>不过，这里加载的初始化数据不一定是RDB的。如果Redis开启了AOF，会优先从AOF初始化数据，否则才会加载RDB的数据。</p><h2 id="RDB优缺点"><a href="#RDB优缺点" class="headerlink" title="RDB优缺点"></a>RDB优缺点</h2><p>优点：      </p><ol><li>RDB是某一时间点的快照，是一个紧凑的单文件，更多用于数据备份。可以按每小时或每日来备份，方便从不同的版本恢复数据。</li><li>单文件容易传输到远程服务做故障恢复。</li><li>RDB可以Fork子进程进行持久化，使Redis可以更好地处理用户请求</li><li>在大量数据的情况下，RDB相比较于AOF会更快的加载。</li></ol><p>缺点：</p><ol><li>如果Redis不及时保存RDB文件，会造成数据的丢失。例如系统突然断电，但未来得及保存数据。即使你设置更多的Save point，也无法保证100%的数据不丢失。</li><li>RDB经常需要fork子进程去执行，但如果再大量数据的情况下，这个fork操作会非常耗CPU资源的。对比AOF虽然也是fork，但是它的数据保存处理是可以控制的，不需要全量保存。</li></ol><h1 id="AOF——日志追加（Append-Only）"><a href="#AOF——日志追加（Append-Only）" class="headerlink" title="AOF——日志追加（Append-Only）"></a>AOF——日志追加（Append-Only）</h1><p>Redis的另外一种持久化方案就是AOF，Append Only File。AOF相当于一个操作的日志记录，每次对于数据的变更都会记录追加到AOF日志。当服务启动的时候就会读这些操作日志，重新执行一次操作，从而恢复原始数据。</p><h2 id="AOF启用"><a href="#AOF启用" class="headerlink" title="AOF启用"></a>AOF启用</h2><p>AOF默认是关闭的。打开redis.conf配置文件，找到<code>appendonly no</code>改成<code>appendonly yes</code>。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/append.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>AOF和RDB是可以共存的，只要保存的文件名不冲突。</p><h2 id="AOF-fsync同步规则"><a href="#AOF-fsync同步规则" class="headerlink" title="AOF fsync同步规则"></a>AOF fsync同步规则</h2><p>配置文件往下拉，看到<code>fsync</code>的配置。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/fsync.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>fsync()是一个系统调用函数，告诉操作系统把数据写到硬盘上，而不是缓存更多数据才写到硬盘。这样的调用可以及时保存数据到硬盘上。</p><p>Redis提供了三种fsync的调用方式</p><ul><li>appendfsync always，每次操作记录都同步到硬盘上，最低效，最安全。</li><li>appendfsync everysec，每秒执行一次把操作记录同步到硬盘上。默认选项。</li><li>appendfsync no，不执行fysnc调用，让操作系统自动操作把缓存数据写到硬盘上，不可靠，但最快。</li></ul><h2 id="AOF文件格式解析"><a href="#AOF文件格式解析" class="headerlink" title="AOF文件格式解析"></a>AOF文件格式解析</h2><p>开启AOF后，会再工作目录看到<code>appendonly.aof</code>文件。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/aof-file.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>在客户端上执行一些命令后，打开AOF文件，可以观察到有对应的操作的记录日志。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/aof-data.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>文件解析说明：</p><ul><li>*，表示命令的参数个数，例如<code>set a 1</code>是三个参数，所以是*3</li><li>$，表示参数的字节数，例如<code>set</code>这个参数是三字节，所以是$3，key值a是一个字节，所以是$1</li><li>无符号，表示是参数的数据，例如<code>set</code>,<code>a</code>,<code>1</code>就是具体的数据</li></ul><h2 id="日志重写"><a href="#日志重写" class="headerlink" title="日志重写"></a>日志重写</h2><p>AOF虽然比RDB更可靠，但缺点也是比较明显的，就是每次写操作都要把操作日志写到文件上，这样会导致文件非常冗余。</p><p>假若你要自增一个计数器100次，如果不重写，AOF文件就就会有这100次的自增记录，如<code>INCR a</code>。如果执行了日志重写，那么文件只会保留<code>set a 100</code>而不是100条<code>INCR a</code>。这样拥有相同的结果，但可以大大减少AOF的文件大小，并且可以让AOF载入的时候提升载入的效率。</p><p>看回<code>redis.conf</code>配置，有两项控制rewrite的选项。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/aof-rewrite.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ul><li>auto-aof-rewrite-percentage 100，当文件增长100%（一倍）时候，自动重写。</li><li>auto-aof-rewrite-min-size 64mb，日志重写最小文件大小，如果小于该大小，不会自动重写。</li></ul><p>来实验一下重写的结果，我们先设定一个a值，然后自增多次，查看AOF文件内容。里面有很多INCR的语句记录<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/incr-test.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>然后我们手动执行下<code>BGREWRITEOF</code>，执行日志重写。<br><img src="http://qiniu.zackku.com/image/redis-rdb-aof/rewrite-test-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>可以看到，多个incr语句，变成了一个<code>set a 6</code>语句，减少了5个<code>incr a</code>语句的操作日志。</p><h2 id="AOF优缺点"><a href="#AOF优缺点" class="headerlink" title="AOF优缺点"></a>AOF优缺点</h2><p>优点：</p><ol><li>AOF可以设置 完全不同步、每秒同步、每次操作同，默认是每秒同步。因为AOF是操作指令的追加，所以可以频繁的大量的同步。</li><li>AOF文件是一个值追加日志的文件，即使服务宕机为写入完整的命令，也可以通过redis-check-aof工具修复这些问题。</li><li>如果AOF文件过大，Redis会在后台自动地重写AOF文件。重写后会使AOF文件压缩到最小所需的指令集。</li><li>AOF文件是有序保存数据库的所有写入操作，易读，易分析。即使如果不小心误操作数据库，也很容易找出错误指令，恢复到某个数据节点。例如不小心FLUSHALL，可以非常容易恢复到执行命令之前。</li></ol><p>缺点</p><ol><li>相同数据量下，AOF的文件通常体积会比RDB大。因为AOF是存指令的，而RDB是所有指令的结果快照。但AOF在日志重写后会压缩一些空间。</li><li>在大量写入和载入的时候，AOF的效率会比RDB低。因为大量写入，AOF会执行更多的保存命令，载入的时候也需要大量的重执行命令来得到最后的结果。RDB对此更有优势。</li></ol><h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><p>以上已经基本了解过RDB和AOF的使用、基本原理以及对应的优缺点。那么在实际当中，我们到底怎么去选择用哪种持久化方式呢？</p><p>一般来说，不考虑硬盘大小，最安全的做法是RDB与AOF同时使用，即使AOF损坏无法修复，还可以用RDB来恢复数据。</p><p>如果Redis的数据在你的服务中并不是必要的数据，例如只是当简单的缓存，没有缓存也不会造成缓存雪崩。说明数据的安全可靠性并不是首要考虑范围内，那么单独只使用RDB就可以了。</p><p>不推荐单独使用AOF，因为AOF对于数据的恢复载入来说，比RDB慢。并且Redis官方也说明了，AOF有一个罕见的bug。出了问题无法很好的解决。所以使用AOF的时候，最好还是有RDB作为数据备份。</p><p><img src="http://qiniu.zackku.com/image/redis-rdb-aof/plan.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>根据官方的意愿描述，在未来可能会有一种RDB与AOF相结合的持久化模型。到时Redis持久化就不再如此麻烦费劲了，我们拭目以待吧。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/redis-rdb-aof/#disqus_thread</comments>
    </item>
    
    <item>
      <title>进阶的Redis之Sentinel原理及实战</title>
      <link>http://zackku.com/redis-sentinel/</link>
      <guid>http://zackku.com/redis-sentinel/</guid>
      <pubDate>Mon, 22 Oct 2018 11:27:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;Redis作为一款高效的内存数据库，可作用于方方面面，相信如今项目的开发都离不开它。大家可能都知道Redis是高可用的，但很少知道具体高可用是利用什么去实现的。&lt;/p&gt;
&lt;p&gt;抛两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;只部署一个Redis实例，如果这个实例挂了就无法读写数据了，那怎么做实例备份？&lt;/li&gt;
&lt;li&gt;部署了两个Redis，一主一从做复制，从只读，如果主挂了，那这个服务还怎么正常对外服务？&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;显然，要做到高可用，首先要有足够多的Redis实例（最好三台以上），一主多从。然后再主挂了的时候，要有机制让其他实例替代主的位置。&lt;/p&gt;
&lt;p&gt;哨兵服务Sentinel，就是这套题的答案，它是一个检查redis服务下线并补偿的服务。下面我们来完整了解下Sentinel的作用和工作原理，最后实验下它的效果。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Redis作为一款高效的内存数据库，可作用于方方面面，相信如今项目的开发都离不开它。大家可能都知道Redis是高可用的，但很少知道具体高可用是利用什么去实现的。</p><p>抛两个问题：</p><ol><li>只部署一个Redis实例，如果这个实例挂了就无法读写数据了，那怎么做实例备份？</li><li>部署了两个Redis，一主一从做复制，从只读，如果主挂了，那这个服务还怎么正常对外服务？</li></ol><p>显然，要做到高可用，首先要有足够多的Redis实例（最好三台以上），一主多从。然后再主挂了的时候，要有机制让其他实例替代主的位置。</p><p>哨兵服务Sentinel，就是这套题的答案，它是一个检查redis服务下线并补偿的服务。下面我们来完整了解下Sentinel的作用和工作原理，最后实验下它的效果。<br><a id="more"></a></p><h1 id="Sentinel简介"><a href="#Sentinel简介" class="headerlink" title="Sentinel简介"></a>Sentinel简介</h1><p>直接看下最新版的官方的介绍<br><img src="http://qiniu.zackku.com/image/redis-sentinel/introduce-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>大致意思是，Sentinel为Redis提供高可用。利用Sentinel，在无人干预的情况下，可用让Redis服务抵御一定程度的故障。</p><p>宏观层面，Sentinel拥有以下几个功能：</p><ul><li>监控（Monitoring），Sentinel可用持续不断地检查主从实例是否如期运行。</li><li>通知（Notification），当某个被监控的Redis实例出问题的时候，可以通过API接口向系统管理员和其他应用服务发通知。</li><li>自动故障转移（Automatic failover），当主出现故障时，Sentinel会自动启动故障转移流程，把其中一个从库提升为主库，然后其他从库重新认新主。集群也会返回新的地址给客户端。</li><li>配置提供（Configuration provider），Sentinel可以作为服务注册中心，让客户端直接连接请求Sentinel去获取主库的地址。如果出现自动故障转移，Sentinel也会提供新的主库地址。</li></ul><p>P.S. 文中所描述的库和服务器都是指Redis的server实例。</p><h1 id="高可用工作原理"><a href="#高可用工作原理" class="headerlink" title="高可用工作原理"></a>高可用工作原理</h1><p>下面我们以Sentinel的故障转移为核心，来看看它具体是怎么实现Sentinel的。</p><ul><li><strong>启动并初始化Sentinel</strong><br>执行 <code>redis-sentinel /usr/local/etc/redis-sentinel.conf</code><br>Sentinel是Redis的特殊模式，执行<code>redis-server /usr/local/etc/redis-sentinel.conf --sentinel</code>命令也是完全一样的。其实在启动Sentinel的时候，redis只是把运行代码切换到sentinel模式。</li><li><strong>初始化master属性</strong><br>配置文件中是需要指定了监控的主库，然后再初始化阶段把Sentinel实例中的master属性初始化。</li><li><strong>Sentinel向主库建立网络连接</strong><br>在master属性初始化后，Sentinel首先就需要和该主库建立网络连接。Sentinel会对每个被监视的主库建立两个链接。一个命令链接，用于给主库发送操作命令的。另一个是订阅链接，订阅主库的__sentinel__:hello频道，主要用于发现其他Sentinel的存在（后面会说到）。</li><li><strong>获取主库信息</strong><br>Sentinel默认以十秒一次，通过命令链接，给主库发送INFO命令，来获取主库的当前信息。信息包括该主库的运行id以及该主库下所有从库的ip端口。</li><li><strong>根据主库信息，获取从库信息</strong><br>如果Sentinel在获取主库信息时候，发现有新未链接的从库，会与该从库同样建立两条链接。建立链接后，Sentinel同样会给从库通过命令链接发送INFO命令，从而获取该从库的服务器信息。</li><li><strong>向主和从发送服务器消息</strong><br>Sentinel默认以两秒一次，通过命令链接，对__sentinel__:hello频道发送Sentinel自身信息与被监控的主库信息。该频道是之前Sentinel与所有主从库都建立的频道链接。所以被监视的主从库都会收到发送消息的Sentinel信息与主库信息。</li><li><strong>接收主从频道消息，找出其他Sentinel</strong><br>因为Sentinel订阅了__sentinel__:hello的消息，所以在之前向主从库发送消息的时候，同时会通过订阅链接收到订阅的内容。这个作用在于，部署多个Sentinel时，其他Sentinel就会知道发送消息的那个Sentinel的存在。</li><li><strong>与其他Sentinel创建连接</strong><br>当Sentinel发现有其他Sentinel存在的时候，就会与其他Sentinel建立一条命令链接，用于在后续情况发送命令。但Sentinel之间不会建立订阅链接，因为订阅链接是用于发现其他Sentinel的存在的。</li><li><strong>主观下线</strong><br>Sentinel默认以一秒一次，通过命令链接，对所有服务器（包括主从、其他Sentinel）发送PING命令来检测服务是否在线。如果一个服务在参数<code>down-after-millisecond</code>内连续返回无效回复，那么Sentinel会对该服务标记为主观下线状态。所谓的主观下线，就是Sentinel自己认为该服务下线了。</li><li><strong>主库客观下线</strong><br>当Sentinel将一个主库主观下线后，为了判断是否其他Sentinel都认为该主库下线了，会通过<code>is-master-down-by-addr</code>命令询问。当认为下线的Sentinel数据大于配置中的quorum数时，Sentinel会标记该主库为客观下线。</li><li><strong>选举Sentinel leader</strong><br>当Sentinel将主库客观下线后，会与其他Sentinel进行协商，选举出一个leader来执行后续的Failover（故障转移）。</li><li><strong>选出新主库</strong>。<br>leader按从库优先级配置、复制偏移量、运行id来选举出新的主库。leader会向挑选出来的从库发送SLAVEOF no one命令，将从库提升为master角色，成为主库。</li><li><strong>让从库复制新主库</strong><br>在选出新主库后，就是让原来的从库去复制新主库。leader Sentinel通过给剩余旧从库发送SLAVEOF命令即可。</li><li><strong>旧主库变为新主库的从库</strong><br>当原来故障的主库再次上线的时候，Sentinel会发送SLAVEOF命令，让其成为新主库的从库。<h1 id="实验实战"><a href="#实验实战" class="headerlink" title="实验实战"></a>实验实战</h1></li></ul><ol><li><p>启动三个Redis实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-server --port 6379 &amp;</span><br><span class="line">redis-server --port 6380 &amp;</span><br><span class="line">redis-server --port 6381 &amp;</span><br></pre></td></tr></table></figure><p>注意最好各个实例的priority不同，用于故障转移选主。否则可能会找不到新主。</p></li><li><p>把80与81的实例作为79的从服务器<br>在80与81上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SLAVEOF 127.0.0.1 6379</span><br></pre></td></tr></table></figure></li><li><p>启动sentinel</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-sentinel /usr/local/etc/redis-sentinel.conf</span><br></pre></td></tr></table></figure><p>其中的Sentinel配置包含</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure><p>可以观察到sentinel已经添加了一主两从的监控。<br><img src="http://qiniu.zackku.com/image/redis-sentinel/sentinel-up.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p></li><li><p>把主库的实例关掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SHUTDOWN</span><br></pre></td></tr></table></figure></li><li><p>故障转移<br>redis-cli连上sentinel可以看到，当sentinel检测到主库下线，后面根据一些列操作把81替换为主库，其他库为81的从库，并且79是下线的新从库。<br><img src="http://qiniu.zackku.com/image/redis-sentinel/part-failover.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p></li></ol><p>参考文献：</p><ul><li><p>《Redis设计与实现》——黄健宏</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p></li></ul>]]></content:encoded>
      
      <comments>http://zackku.com/redis-sentinel/#disqus_thread</comments>
    </item>
    
    <item>
      <title>浅谈分布式CAP定理</title>
      <link>http://zackku.com/cap/</link>
      <guid>http://zackku.com/cap/</guid>
      <pubDate>Wed, 17 Oct 2018 11:29:13 GMT</pubDate>
      <description>
      
        &lt;p&gt;互联网发展到现在，由于数据量大、操作并发高等问题，大部分网站项目都采用分布式的架构。而分布式系统最大的特点数据分散，在不同网络节点在某些时刻（数据未同步完，数据丢失），数据会不一致。&lt;/p&gt;
&lt;p&gt;在2000年，Eric Brewer教授在PODC的研讨会上提出了一个猜想：一致性、可用性和分区容错性三者无法在分布式系统中被同时满足，并且最多只能满足其中两个！&lt;/p&gt;
&lt;p&gt;在2002年，Lynch证明其猜想，上升为定理。被这就是大家所认知的CAP定理。&lt;/p&gt;
&lt;p&gt;CAP是所有分布式数据库的设计标准。例如Zookeeper、Redis、HBase等的设计都是基于CAP理论的。&lt;/p&gt;
&lt;h1 id=&quot;CAP定义&quot;&gt;&lt;a href=&quot;#CAP定义&quot; class=&quot;headerlink&quot; title=&quot;CAP定义&quot;&gt;&lt;/a&gt;CAP定义&lt;/h1&gt;&lt;p&gt;所谓的CAP就是分布式系统的三个特性：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/cap/cap-concept.jpeg?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>互联网发展到现在，由于数据量大、操作并发高等问题，大部分网站项目都采用分布式的架构。而分布式系统最大的特点数据分散，在不同网络节点在某些时刻（数据未同步完，数据丢失），数据会不一致。</p><p>在2000年，Eric Brewer教授在PODC的研讨会上提出了一个猜想：一致性、可用性和分区容错性三者无法在分布式系统中被同时满足，并且最多只能满足其中两个！</p><p>在2002年，Lynch证明其猜想，上升为定理。被这就是大家所认知的CAP定理。</p><p>CAP是所有分布式数据库的设计标准。例如Zookeeper、Redis、HBase等的设计都是基于CAP理论的。</p><h1 id="CAP定义"><a href="#CAP定义" class="headerlink" title="CAP定义"></a>CAP定义</h1><p>所谓的CAP就是分布式系统的三个特性：</p><p><img src="http://qiniu.zackku.com/image/cap/cap-concept.jpeg?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><a id="more"></a><ul><li>Consistency，一致性。所有分布式节点的数据是否一致。</li><li>Availability，可用性。在部分节点有问题的情况（数据不一致、节点故障）下，是否能继续响应服务（可用）。</li><li>Partition tolerance，分区容错性。允许在节点（分区）数据不一致的情况。</li></ul><h1 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h1><p>有A、B、C三个分布式数据库。</p><p><img src="http://qiniu.zackku.com/image/cap/demo.jpeg?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>当A、B、C的数据是完全相同，那么就符合定理中的Consistency（一致性）。</p><p>假如A的数据与B的数据不相同，但是整体的服务（包含A、B、C的整体）没有宕机，依然可以对外系统服务，那么就符合定理中的Availability（可用性）。</p><p>分布式数据库是没有办法百分百时刻保持各个节点数据一致的。假设一个用户再A库上更新了一条记录，在更新完这一刻，A与B、C库的数据是不一致的。这种情况在分布式数据库上是必然存在的。这就是Partition tolerance（分区容错性）</p><p>当数据不一致的时候，必定是满足分区容错性，如果不满足，那么这个就不是一个可靠的分布式系统。</p><p>然而在数据不一致的情况下，系统要么选择优先保持数据一致性，这样的话。系统首先要做的是数据的同步操作，此时需要暂停系统的响应。这就是满足CP。</p><p>若系统优先选择可用性，那么在数据不一致的情况下，会在第一时间放弃一致性，让整体系统依然能运转工作。这就是AP。</p><p>所以，分布式系统在通常情况下，要不就满足CP，要不就满足AP。</p><p>那么有没有满足CA的呢？有，当分布式节点为1的时候，不存在P，自然就会满足CA了。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>上面说到，分区容错性是分布式系统中必定要满足的，需要权衡的是系统的一致性与可用性。那么常见的分布式系统是基于怎样的权衡设计的。</p><ul><li>Zookeeper<br>保证CP。当主节点故障的时候，Zookeeper会重新选主。此时Zookeeper是不可用的，需要等待选主结束才能重新提供注册服务。显然，Zookeeper在节点故障的时候，并没有满足可用性的特性。在网络情况复杂的生产环境下，这样的的情况出现的概率也是有的。一旦出现，如果依赖Zookeeper的部分会卡顿，在大型系统上，很容易引起系统的雪崩。这也是大型项目不选Zookeeper当注册中心的原因。</li><li>Eureka<br>保证AP。在Eureka中，各个节点是平等的，它们相互注册。挂掉几个节点依然可以提供注册服务的（可以配置成挂掉的比例），如果连接的Eureka发现不可用，会自动切换到其他可用的几点上。另外，当一个服务尝试连接Eureka发现不可用的时候，切换到另外一个Eureka服务上，有可能由于故障节点未来得及同步最新配置，所以这个服务读取的数据可能不是最新的。所以当不要求强一致性的情况下，Eureka作为注册中心更为可靠。</li><li>Git<br>其实Git也是也是分布式数据库。它保证的是CP。很容易猜想到，云端的Git仓库于本地仓库必定是要保证数据的一致性的，如果不一致会先让数据一致再工作。当你修改完本地代码，想push代码到Git仓库上时，假如云端的HEAD与本地的HEAD不一致的时候，会先同步云端的HEAD到本地HEAD，再把本地的HEAD同步到云端。最终保证数据的一致性。</li></ul><hr><p>更多技术文章、精彩干货，请关注<br>个人博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/cap/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java异步编程——深入源码分析FutureTask</title>
      <link>http://zackku.com/java-thread-future/</link>
      <guid>http://zackku.com/java-thread-future/</guid>
      <pubDate>Tue, 09 Oct 2018 02:09:52 GMT</pubDate>
      <description>
      
        &lt;p&gt;Java的异步编程是一项非常常用的多线程技术。&lt;/p&gt;
&lt;p&gt;之前通过源码详细分析了ThreadPoolExecutor&lt;a href=&quot;/java-thread-threadpoolexecutor/&quot;&gt;《你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识》&lt;/a&gt;。通过创建一个ThreadPoolExecutor，往里面丢任务就可以实现多线程异步执行了。&lt;/p&gt;
&lt;p&gt;但之前的任务主要倾向于线程池，并没有讲到异步编程方面的内容。本文将通过介绍Executor+Future框架（FutureTask是实现的核心），来深入了解下Java的异步编程。&lt;/p&gt;
&lt;p&gt;万事从示例开始，我们先通过示例Demo有一个直观的印象，再深入去了解概念与原理。&lt;/p&gt;
&lt;h1 id=&quot;使用示例&quot;&gt;&lt;a href=&quot;#使用示例&quot; class=&quot;headerlink&quot; title=&quot;使用示例&quot;&gt;&lt;/a&gt;使用示例&lt;/h1&gt;&lt;p&gt;Demo：&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-thread-futuretask/demo-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Java的异步编程是一项非常常用的多线程技术。</p><p>之前通过源码详细分析了ThreadPoolExecutor<a href="/java-thread-threadpoolexecutor/">《你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识》</a>。通过创建一个ThreadPoolExecutor，往里面丢任务就可以实现多线程异步执行了。</p><p>但之前的任务主要倾向于线程池，并没有讲到异步编程方面的内容。本文将通过介绍Executor+Future框架（FutureTask是实现的核心），来深入了解下Java的异步编程。</p><p>万事从示例开始，我们先通过示例Demo有一个直观的印象，再深入去了解概念与原理。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>Demo：<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/demo-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><a id="more"></a>使用上比较简单，</p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">任务1异步执行：0</span><br><span class="line">任务2异步执行：0</span><br><span class="line">任务2异步执行：1</span><br><span class="line">...</span><br><span class="line">任务2异步执行：45</span><br><span class="line">同步代码</span><br><span class="line">任务2异步执行：24</span><br><span class="line">...</span><br><span class="line">任务1异步执行：199</span><br><span class="line">任务1:执行完成</span><br><span class="line">...</span><br><span class="line">任务2异步执行：199</span><br><span class="line">任务2：执行完成</span><br></pre></td></tr></table></figure></p><p>假若你多次执行这个程序，会发现结果大大的不一样，因为两个任务和同步代码是异步由多条线程执行的，打印的结果当然是随机的。</p><p>回顾这个Demo做了什么，</p><ol><li>构建了一个线程池</li><li>往线程池里面丢两个需要执行的任务</li><li>最后获取这两个任务的结果</li></ol><p>其中第二点是异步执行两个任务，这两个任务和主线程分别是用了三个线程并发执行的，第三点是在主线程中同步等待两个任务的结果。</p><p>很容易看出来，异步编程的好处就在于可以让不相干的任务异步执行，不阻塞主线程。若是主线程需要异步执行的结果，此时再去等待结果会更加高效，提高程序的执行效率。</p><p>下面来看看整个流程的实现原理。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>一般在实际项目中，都会有配置有自己的线程池，建议大家在用异步编程时，配置一个专用的线程池，做好线程隔离，避免异步线程影响到其他模块的工作。Demo中为了方便，直接调用Exectors的方法生成一个临时的线程池，日常不建议使用。</p><p>我们从这个<code>ExecutorService.submit()</code>方法入手，看看整体实现。</p><p><img src="http://qiniu.zackku.com/image/java-thread-futuretask/executor-submit.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><code>ExecutorService.submit()</code>定义一个接口。这个接口接收一个Callable参数（执行的任务），返回一个Future（计算结果）。</p><p><code>Callable</code>，相当于一个需要执行的任务。它不接收任何参数，可以返回结果，可以抛出异常。相类似的还有<code>Runnable</code>，它也是不接收，不同点在于它不返回结果，也不抛异常，异常需要在任务内部处理。总结来说<code>Callable</code>更像一个方法的调用，<code>Runnable</code>则是一个不需要理会结果的调用。在JDK 8以后，它们都可以通过Lamda表达式写法去替代内部类的写法（详见Demo）。</p><p><code>Future</code>，一个异步计算的结果。调用<code>get()</code>方法可以得到对应的计算结果，如果调用时没有异步计算完，会阻塞等待计算的结果。同时它还提供方法可以尝试取消任务的执行。</p><p>看回<code>ExecutorService.submit()</code>的实现，代码在实现类<code>AbstractExecutorService</code>中。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/submit-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>除了它接口的实现，还提供了两种变形。原来接口只接收<code>Callable</code>参数，实现类中还新增了接收<code>Runnable</code>参数的。</p><p>如果看过之前写的<a href="/java-thread-threadpoolexecutor/">《你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识》</a>，应该了解<code>ThreadPoolExecutor</code>执行任务是可以调用<code>execute()</code>方法的。而这里面<code>submit()</code>方法则是为<code>Callable/Runnable</code>加多一层<code>FutureTask</code>，从而<br>使执行结果有一个存放的地方，同时也添加一个可以取消的功能。原本的<code>execute()</code>只能执行任务，不会返回结果的，具体实现原理可以看看之前的文章分析。</p><p><code>FutureTask</code>是<code>RunnableFuture</code>的实现。而<code>RunnableFuture</code>是继承<code>Future</code>和<code>Runnable</code>接口的，定义<code>run()</code>接口。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/futuretask.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>因为<code>FutureTask</code>有<code>run()</code>接口，所以可以直接用一个<code>Callable/Runnable</code>创建一个<code>FutureTask</code>单独执行。但这样并没有异步的效果，因为没有启用新的线程去跑，而是在原来的线程阻塞执行的。</p><p><strong>到这里我们清楚知道了，<code>submit()</code>方法重点是利用<code>Callable/Runnable</code>创建一个<code>FutureTask</code>，然后多线程执行<code>run()</code>方法，达到异步处理并且得到结果的效果。而<code>FutureTask</code>的重点则是<code>run()</code>方法如何持有保存计算的结果。</strong></p><h2 id="FutureTask-run"><a href="#FutureTask-run" class="headerlink" title="FutureTask.run()"></a>FutureTask.run()</h2><p><img src="http://qiniu.zackku.com/image/java-thread-futuretask/run.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>首先判断<code>futureTask</code>对象的<code>state</code>状态，如果不是NEW的话，证明已经开始运行过了，则退出执行。同时<code>futureTask</code>对象通过CAS，把当前线程赋值给变量<code>runner</code>（是Thread类型，说明对象使用哪个线程执行的），如果CAS失败则退出。</p><p>外层<code>try{}</code>代码块中，对<code>callable</code>判空和<code>state</code>状态必须是NEW。内层<code>try{}</code>代码真正调用<code>callable</code>，开始执行任务。若执行成功，则把<code>ran</code>变量设为true，保存结果在<code>result</code>变量中，证明已跑成功过了；若抛异常了，则设为false，<code>result</code>为空，并且调用<code>setException()</code>保存异常。最后如果<code>ran</code>为true的话，则调用<code>set()</code>保存<code>result</code>结果。</p><p>看下<code>setException()</code>和<code>set()</code>的实现。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/set.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>两者的基本流程一样，CAS置换状态，保存结果在<code>outcome</code>变量道中，但<code>setException()</code>保存的结果类型固定是<code>Throwable</code>。另外一个不同在于最终<code>state</code>状态，一个是EXCEPTION，一个是NORMAL。</p><p>这两个方法最后都调用了<code>finishCompletion()</code>。这个方法主要是配合线程池唤醒下一个任务。</p><h2 id="FutureTask-get"><a href="#FutureTask-get" class="headerlink" title="FutureTask.get()"></a>FutureTask.get()</h2><p>从上面<code>run()</code>方法得知，最后执行的结果放在了<code>outcome</code>变量中。那最终怎么从其中取出结果来，我们来看看<code>get()</code>方法。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/get.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从源码可知，<code>get()</code>方法分两步。第一步，先判断状态，如果计算为完成，则需要阻塞地等待完成。第二步，如果完成了，则调用<code>report()</code>方法获取结果并返回。</p><p>先看看<code>awaitDone()</code>阻塞等待完成。该方法可以选用超时功能。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/awaitdone.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>在自旋的for()循环中，</p><ul><li>先判断是否线程被中断，中断的话抛异常退出。</li><li>然后开始判断运行的<code>state</code>值，如果<code>state</code>大于<code>COMPLETING</code>，证明计算已经是终态了，此时返回终态变量。</li><li>若<code>state</code>等于<code>COMPLETING</code>，证明已经开始计算，并且还在计算中。此时为了避免过多的CPU时间放在这个for循环的自旋上，程序执行<code>Thread.yield()</code>，把线程从运行态降为就绪态，让出CPU时间。</li><li>若以上状态都不是，则证明<code>state</code>为<code>NEW</code>，还没开始执行。那么程序在当前循环现在会新增一个<code>WaitNode</code>，在下一个循环里面调用<code>LockSupport.park()</code>把当前线程阻塞。当<code>run()</code>方法结束的时候，会再次唤醒此线程，避免自旋消耗CPU时间。</li><li>如果选用了超时功能，在阻塞和自旋过程中超时了，则会返回当前超时的状态。</li></ul><p>第二步的<code>report()</code>方法比较简单。<br><img src="http://qiniu.zackku.com/image/java-thread-futuretask/report.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ul><li>如果状态是<code>NORMAL</code>，正常结束的话，则把<code>outcome</code>变量返回；</li><li>如果是取消或者中断状态的，则抛出取消异常；</li><li>如果是<code>EXCEPTION</code>，则把<code>outcome</code>当作异常抛出（之前<code>setException()</code>保存的类型就是<code>Throwable</code>）。从而整个<code>get()</code>会有一个异常抛出。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此我们已经比较完整地了解Executor+Future的框架原理了，而FutureTask则是该框架的主要实现。下面总结下要点</p><ol><li><code>Executor.sumbit()</code>方法异步执行一个任务，并且返回一个Future结果。</li><li><code>submit()</code>的原理是利用<code>Callable</code>创建一个<code>FutureTask</code>对象，然后执行对象的<code>run()</code>方法，把结果保存在<code>outcome</code>中。</li><li>调用<code>get()</code>获取<code>outcome</code>时，如果任务未完成，会阻塞线程，等待执行完毕。</li><li>异常和正常结果都放在<code>outcome</code>中，调用<code>get()</code>获取结果或抛出异常。</li></ol><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-future/#disqus_thread</comments>
    </item>
    
    <item>
      <title>一文了解JVM全部垃圾回收器，从Serial到ZGC</title>
      <link>http://zackku.com/jvm-gc-collector/</link>
      <guid>http://zackku.com/jvm-gc-collector/</guid>
      <pubDate>Fri, 28 Sep 2018 07:31:15 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;a href=&quot;/jvm-gc-base&quot;&gt;《对象搜索算法与回收算法》&lt;/a&gt;介绍了垃圾回收的基础算法，相当于垃圾回收的方法论。接下来就详细看看垃圾回收的具体实现。&lt;/p&gt;
&lt;p&gt;上文提到过现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器。常用的7种收集器，其适用的范围如图所示&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/jvm-gc-collector/collectors.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p><a href="/jvm-gc-base">《对象搜索算法与回收算法》</a>介绍了垃圾回收的基础算法，相当于垃圾回收的方法论。接下来就详细看看垃圾回收的具体实现。</p><p>上文提到过现代的商用虚拟机的都是采用分代收集的，不同的区域用不同的收集器。常用的7种收集器，其适用的范围如图所示</p><p><img src="http://qiniu.zackku.com/image/jvm-gc-collector/collectors.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><a id="more"></a><br>Serial、ParNew、Parallel Scavenge用于新生代；<br>CMS、Serial Old、Paralled Old用于老年代。<br>并且他们相互之间以相对固定的组合使用（具体组合关系如上图）。G1是一个独立的收集器不依赖其他6种收集器。ZGC是目前JDK 11的实验收集器。</p><p>下面来看看各个收集器的特性</p><h1 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h1><p>Serial，是单线程执行垃圾回收的。当需要执行垃圾回收时，程序会暂停一切手上的工作，然后单线程执行垃圾回收。</p><p>因为新生代的特点是对象存活率低，所以收集算法用的是复制算法，把新生代存活对象复制到老年代，复制的内容不多，性能较好。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/serial.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>单线程地好处就是减少上下文切换，减少系统资源的开销。但这种方式的缺点也很明显，在GC的过程中，会暂停程序的执行。若GC不是频繁发生，这或许是一个不错的选择，否则将会影响程序的执行性能。<br>对于新生代来说，区域比较小，停顿时间短，所以比较使用。</p><h1 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h1><p>ParNew同样用于新生代，是Serial的多线程版本，并且在参数、算法（同样是复制算法）上也完全和Serial相同。</p><p>Par是Parallel的缩写，但它的并行仅仅指的是收集多线程并行，并不是收集和原程序可以并行进行。ParNew也是需要暂停程序一切的工作，然后多线程执行垃圾回收。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/parnew.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>因为是多线程执行，所以在多CPU下，ParNew效果通常会比Serial好。但如果是单CPU则会因为线程的切换，性能反而更差。</p><h1 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h1><p>新生代的收集器，同样用的是复制算法，也是并行多线程收集。与ParNew最大的不同，它关注的是垃圾回收的吞吐量。</p><p>这里的吞吐量指的是 总时间与垃圾回收时间的比例。这个比例越高，证明垃圾回收占整个程序运行的比例越小。</p><p>Parallel Scavenge收集器提供两个参数控制垃圾回收的执行：</p><ul><li><strong>-XX:MaxGCPauseMillis</strong>，最大垃圾回收停顿时间。这个参数的原理是空间换时间，收集器会控制新生代的区域大小，从而尽可能保证回收少于这个最大停顿时间。简单的说就是回收的区域越小，那么耗费的时间也越小。<br>所以这个参数并不是设置得越小越好。设太小的话，新生代空间会太小，从而更频繁的触发GC。</li><li><strong>-XX:GCTimeRatio</strong>，垃圾回收时间与总时间占比。这个是吞吐量的倒数，原理和MaxGCPauseMillis相同。</li></ul><p>因为Parallel Scavenge收集器关注的是吞吐量，所以当设置好以上参数的时候，同时不想设置各个区域大小（新生代，老年代等）。可以开启<strong>-XX:UseAdaptiveSizePolicy</strong>参数，让JVM监控收集的性能，动态调整这些区域大小参数。</p><h1 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h1><p>老年代的收集器，与Serial一样是单线程，不同的是算法用的是标记-整理（Mark-Compact）。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/serial-old.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>因为老年代里面对象的存活率高，如果依旧是用复制算法，需要复制的内容较多，性能较差。并且在极端情况下，当存活为100%时，没有办法用复制算法。所以需要用Mark-Compact，以有效地避免这些问题。</p><h1 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h1><p>老年代的收集器，是Parallel Scavenge老年代的版本。其中的算法替换成Mark-Compact。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/parallel-old.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h1 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h1><p>CMS，Concurrent Mark Sweep，同样是老年代的收集器。它关注的是垃圾回收最短的停顿时间（低停顿），在老年代并不频繁GC的场景下，是比较适用的。</p><p>命名中用的是concurrent，而不是parallel，说明这个收集器是有与工作执行并发的能力的。MS则说明算法用的是Mark Sweep算法。</p><p>来看看具体地工作原理。CMS整个过程比之前的收集器要复杂，整个过程分为四步：</p><ul><li>初始标记（initial mark），单线程执行，需要“Stop The World”，但仅仅把GC Roots的直接关联可达的对象给标记一下，由于直接关联对象比较小，所以这里的速度非常快。</li><li>并发标记（concurrent mark），对于初始标记过程所标记的初始标记对象，进行并发追踪标记，此时其他线程仍可以继续工作。此处时间较长，但不停顿。</li><li>重新标记（remark），在并发标记的过程中，由于可能还会产生新的垃圾，所以此时需要重新标记新产生的垃圾。此处执行并行标记，与用户线程不并发，所以依然是“Stop The World”，时间比初始时间要长一点。</li><li>并发清除（concurrent sweep），并发清除之前所标记的垃圾。其他用户线程仍可以工作，不需要停顿。</li></ul><p><img src="http://qiniu.zackku.com/image/jvm-gc-collector/cms.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>由于最耗费时间的并发标记与并发清除阶段都不需要暂停工作，所以整体的回收是低停顿的。</p><p>由于CMS以上特性，缺点也是比较明显的，</p><ul><li>Mark Sweep算法会导致内存碎片比较多</li><li>CMS的并发能力依赖于CPU资源，所以在CPU数少和CPU资源紧张的情况下，性能较差</li><li>并发清除阶段，用户线程依然在运行，所以依然会产生新的垃圾，此阶段的垃圾并不会再本次GC中回收，而放到下次。所以GC不能等待内存耗尽的时候才进行GC，这样的话会导致并发清除的时候，用户线程可以了利用的空间不足。所以这里会浪费一些内存空间给用户线程预留。</li></ul><p><strong>有人会觉得既然Mark Sweep会造成内存碎片，那么为什么不把算法换成Mark Compact呢？</strong></p><p><strong>答案其实很简答，因为当并发清除的时候，用Compact整理内存的话，原来的用户线程使用的内存还怎么用呢？要保证用户线程能继续执行，前提的它运行的资源不受影响嘛。Mark Compact更适合“Stop the World”这种场景下使用。</strong></p><h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>G1，Garbage First，在JDK 1.7版本正式启用，是当时最前沿的垃圾收集器。G1可以说是CMS的终极改进版，解决了CMS内存碎片、更多的内存空间登问题。虽然流程与CMS比较相似，但底层的原理已是完全不同。</p><p><strong>高效益优先</strong>。G1会预测垃圾回收的停顿时间，原理是计算老年代对象的效益率，优先回收最大效益的对象。</p><p><strong>堆内存结构的不同</strong>。以前的收集器分代是划分新生代、老年代、持久代等。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/g1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>G1则是把内存分为多个大小相同的区域Region，每个Region拥有各自的分代属性，但这些分代不需要连续。<br><img src="http://qiniu.zackku.com/image/jvm-gc-collector/g1-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>这样的分区可以有效避免内存碎片化问题。</p><p>但是这样同样会引申一个新的问题，就是分代的内存不连续，导致在GC搜索垃圾对象的时候需要全盘扫描找出引用内存所在。</p><p>为了解决这个问题，G1对于每个Region都维护一个Remembered Set，用于记录对象引用的情况。当GC发生的时候根据Remembered Set的引用情况去搜索。</p><p><strong>两种GC模式</strong>：</p><ul><li>Young GC，关注于所有年轻代的Region，通过控制收集年轻代的Region个数，从而控制GC的回收时间。</li><li>Mixed GC，关注于所有年轻代的Region，并且加上通过预测计算最大收益的若干个老年代Region。</li></ul><p>整体的执行流程：</p><ul><li>初始标记（initial mark），标记了从GC Root开始直接关联可达的对象。STW（Stop the World）执行。</li><li>并发标记（concurrent marking），并发标记初始标记的对象，此时用户线程依然可以执行。</li><li>最终标记（Remark），STW，标记再并发标记过程中产生的垃圾。</li><li>筛选回收（Live Data Counting And Evacuation），评估标记垃圾，根据GC模式回收垃圾。STW执行。</li></ul><p><img src="http://qiniu.zackku.com/image/jvm-gc-collector/g1-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>在Region层面上，整体的算法偏向于Mark-Compact。因为是Compact，会影响用户线程执行，所以回收阶段需要STW执行。</p><h1 id="令人惊叹的ZGC"><a href="#令人惊叹的ZGC" class="headerlink" title="令人惊叹的ZGC"></a>令人惊叹的ZGC</h1><p>在JDK 11当中，加入了实验性质的ZGC。它的回收耗时平均不到2毫秒。它是一款低停顿高并发的收集器。</p><p>ZGC几乎在所有地方并发执行的，除了初始标记的是STW的。所以停顿时间几乎就耗费在初始标记上，这部分的实际是非常少的。那么其他阶段是怎么做到可以并发执行的呢？</p><p>ZGC主要新增了两项技术，一个是<strong>着色指针Colored Pointer</strong>，另一个是<strong>读屏障Load Barrier</strong>。</p><p><strong>着色指针Colored Pointer</strong><br>ZGC利用指针的64位中的几位表示Finalizable、Remapped、Marked1、Marked0（ZGC仅支持64位平台），以标记该指向内存的存储状态。相当于在对象的指针上标注了对象的信息。注意，这里的指针相当于Java术语当中的引用。</p><p>在这个被指向的内存发生变化的时候（内存在Compact被移动时），颜色就会发生变化。</p><p>在G1的时候就说到过，Compact阶段是需要STW，否则会影响用户线程执行。那么怎么解决这个问题呢？</p><p><strong>读屏障Load Barrier</strong><br>由于着色指针的存在，在程序运行时访问对象的时候，可以轻易知道对象在内存的存储状态（通过指针访问对象），若请求读的内存在被着色了。那么则会触发读屏障。读屏障会更新指针再返回结果，此过程有一定的耗费，从而达到与用户线程并发的效果。</p><p>把这两项技术联合下理解，引用R大（RednaxelaFX）的话</p><blockquote><p>与标记对象的传统算法相比，ZGC在指针上做标记，在访问指针时加入Load Barrier（读屏障），比如当对象正被GC移动，指针上的颜色就会不对，这个屏障就会先把指针更新为有效地址再返回，也就是，永远只有单个对象读取时有概率被减速，而不存在为了保持应用与GC一致而粗暴整体的Stop The World。</p></blockquote><p>ZGC虽然目前还在JDK 11还在实验阶段，但由于算法与思想是一个非常大的提升，相信在未来不久会成为主流的GC收集器使用。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/jvm-gc-collector/#disqus_thread</comments>
    </item>
    
    <item>
      <title>必知必会JVM垃圾回收——对象搜索算法与回收算法</title>
      <link>http://zackku.com/jvm-gc-base/</link>
      <guid>http://zackku.com/jvm-gc-base/</guid>
      <pubDate>Thu, 27 Sep 2018 07:09:36 GMT</pubDate>
      <description>
      
        &lt;p&gt;垃圾回收（GC）是JVM的一大杀器，它使程序员可以更高效地专注于程序的开发设计，而不用过多地考虑对象的创建销毁等操作。但是这并不是说程序员不需要了解GC。GC只是Java编程中一项自动化工具，任何一个工具都有它适用的范围，当超出它的范围的时候，可能它将不是那么自动，而是需要人工去了解与适应地适用。&lt;/p&gt;
&lt;p&gt;拥有一定工作年限的程序员，在工作期间肯定会经常碰到像内存溢出、内存泄露、高并发的场景。这时候在应对这些问题或场景时，如果对GC不了解，很可能会成为个人的发展瓶颈。&lt;/p&gt;
&lt;p&gt;接下来的两文将详细学习下JVM中垃圾回收（GC）的各个知识要点。本文先从GC的算法开始先了解，铺垫好基础，下一篇再详细讲JVM具体的GC实现。&lt;/p&gt;
&lt;h1 id=&quot;GC对象搜索算法&quot;&gt;&lt;a href=&quot;#GC对象搜索算法&quot; class=&quot;headerlink&quot; title=&quot;GC对象搜索算法&quot;&gt;&lt;/a&gt;GC对象搜索算法&lt;/h1&gt;&lt;p&gt;垃圾回收，第一件事就是要搞清楚哪些东西是垃圾，而后才能对这些垃圾进行回收。&lt;/p&gt;
&lt;p&gt;那么有什么办法识别对象是否为无用的垃圾呢？狭义地，怎么判断对象是否没被引用呢？&lt;/p&gt;
&lt;p&gt;通常有以下两种算法去识别判断
      
      </description>
      
      <content:encoded><![CDATA[<p>垃圾回收（GC）是JVM的一大杀器，它使程序员可以更高效地专注于程序的开发设计，而不用过多地考虑对象的创建销毁等操作。但是这并不是说程序员不需要了解GC。GC只是Java编程中一项自动化工具，任何一个工具都有它适用的范围，当超出它的范围的时候，可能它将不是那么自动，而是需要人工去了解与适应地适用。</p><p>拥有一定工作年限的程序员，在工作期间肯定会经常碰到像内存溢出、内存泄露、高并发的场景。这时候在应对这些问题或场景时，如果对GC不了解，很可能会成为个人的发展瓶颈。</p><p>接下来的两文将详细学习下JVM中垃圾回收（GC）的各个知识要点。本文先从GC的算法开始先了解，铺垫好基础，下一篇再详细讲JVM具体的GC实现。</p><h1 id="GC对象搜索算法"><a href="#GC对象搜索算法" class="headerlink" title="GC对象搜索算法"></a>GC对象搜索算法</h1><p>垃圾回收，第一件事就是要搞清楚哪些东西是垃圾，而后才能对这些垃圾进行回收。</p><p>那么有什么办法识别对象是否为无用的垃圾呢？狭义地，怎么判断对象是否没被引用呢？</p><p>通常有以下两种算法去识别判断<a id="more"></a></p><ul><li><p><strong>引用计数算法</strong><br>这个算法非常简单。给对象一个计数器，每当这个对象被引用了，计数器值加一；引用失效，则减一。但这个对象计数值为0的时候，证明是无用对象，可以被GC程序回收掉。这种算法比较广泛应用在一些脚本语言上，如FLASH、PYTHON等。<br>但是引用计数算法无法解决对象间相互引用的问题。当a对象引用了b对象，b对象也引用了a对象，这样a、b两个对象的计数器值都不会为0，即使这两个对象都被其他对象所引用，最终导致这些对象一直无法被回收。这种情况往往会出现在比较复杂的编程语言中。<br><img src="http://qiniu.zackku.com/image/jvm-gc-base/refer-count.png?imageView2/0/q/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p></li><li><p><strong>可达性分析算法</strong><br>可达性分析算法（GC roots算法），广泛应用于主流的商用语言。设置一个根节点，从图论角度来看，只要从该节点可达一个对象，证明这个对象是存活的（被引用）。<br><img src="http://qiniu.zackku.com/image/jvm-gc-base/gc-roots.jpeg?imageView2/0/q/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p></li></ul><p>通常地，GC会包含以下区域的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li></ul><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>了解完垃圾是怎么找出来后，接下来看看它们是怎么被清除的。以下介绍几种清除的算法。</p><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><p>标记-清除，顾名思义，先标记垃圾，再清除。它是GC最基础的算法，后续很多算法都是基于它上面去改进的。<br>标记的过程在上面搜索GC对象已经介绍过了。被标记的对象，在统一GC的时候会把标记的对象清除掉。这个算法比较简单，不做过多赘述。</p><p><img src="http://qiniu.zackku.com/image/jvm-gc-base/mark-sweep.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个算法有一个很明显的缺点，就是在垃圾回收后会产生大量不连续的碎片空间，导致程序要申请较大的对象时常无法找到合适的内存空间，迫使再次GC。</p><h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>复制算法的存在，正是为了解决内存碎片问题。并且这个算法也是分代算法的基础。</p><p>将内存分为大小相等的两块，每次程序只使用其中一块，当GC发生的时候，把存活的对象复制到另外一块内存中，整齐的排列，然后清空原来的那块内存。<br><img src="http://qiniu.zackku.com/image/jvm-gc-base/copy.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>可以看到，这种算法有点新生代转移到老年代的感觉。</p><p>缺点：</p><ol><li>把内存可使用的空间减少了一半，造成空间的浪费。</li><li>对象存活数量较多的时候，复制性能比较差</li></ol><p>这种缺点，在老年代中，对象存活率比较高的场景下是非常场景间。</p><h2 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h2><p>针对复制算法的两个缺点，在老年代一般会用这种标记-整理算法。</p><p>把存活的对象移到内存的一段，然后把剩余的空间全部清空掉。<br><img src="http://qiniu.zackku.com/image/jvm-gc-base/mark-compact.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>分代算法并不是一个特定的算法，也没有什么新的内容。而是把内存分成多个区域，一般为新生代、老年代等。然后根据不同区域不同的特点，用不同回收算法去回收垃圾。</p><p>例如新生代，对象存活率低，比较适用复制算法。老年代存活率高，比较适用Mark-Compact算法。</p><p>目前几乎所有的商业虚拟机都是采用分代收集的。具体不同的收集器在下一文再详细说明。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/jvm-gc-base/#disqus_thread</comments>
    </item>
    
    <item>
      <title>从源码入手，一文带你读懂Spring AOP面向切面编程</title>
      <link>http://zackku.com/spring-aop/</link>
      <guid>http://zackku.com/spring-aop/</guid>
      <pubDate>Thu, 13 Sep 2018 14:45:56 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前&lt;a href=&quot;/spring-ioc&quot;&gt;《零基础带你看Spring源码——IOC控制反转》&lt;/a&gt;详细讲了Spring容器的初始化和加载的原理，后面&lt;a href=&quot;/java-dynamic-proxy&quot;&gt;《你真的完全了解Java动态代理吗？看这篇就够了》&lt;/a&gt;介绍了下JDK的动态代理。&lt;/p&gt;
&lt;p&gt;基于这两者的实现上，这次来探索下Spring的AOP原理。虽然AOP是基于Spring容器和动态代理，但不了解这两者原理也丝毫不影响理解AOP的原理实现，因为大家起码都会用。&lt;/p&gt;
&lt;p&gt;AOP，Aspect Oriented Programming，面向切面编程。在很多时候我们写一些功能的时候，不需要用到继承这么重的方法，例如对每个方法在执行前打log，在没有AOP的情况下，我们只能对每个方法都写一句打log的语句。如果是一个复杂点的功能，那么将会产生许多重复的代码，而且会对模块之间有更多的耦合。&lt;br&gt;然而，在AOP下，我们只需要通过特定的方法，就能直接切入代码，添加自定义的功能（后续再讲AOP里面的概念点）。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>之前<a href="/spring-ioc">《零基础带你看Spring源码——IOC控制反转》</a>详细讲了Spring容器的初始化和加载的原理，后面<a href="/java-dynamic-proxy">《你真的完全了解Java动态代理吗？看这篇就够了》</a>介绍了下JDK的动态代理。</p><p>基于这两者的实现上，这次来探索下Spring的AOP原理。虽然AOP是基于Spring容器和动态代理，但不了解这两者原理也丝毫不影响理解AOP的原理实现，因为大家起码都会用。</p><p>AOP，Aspect Oriented Programming，面向切面编程。在很多时候我们写一些功能的时候，不需要用到继承这么重的方法，例如对每个方法在执行前打log，在没有AOP的情况下，我们只能对每个方法都写一句打log的语句。如果是一个复杂点的功能，那么将会产生许多重复的代码，而且会对模块之间有更多的耦合。<br>然而，在AOP下，我们只需要通过特定的方法，就能直接切入代码，添加自定义的功能（后续再讲AOP里面的概念点）。<br><a id="more"></a><br>下面将从一个简单的示例入手，拆解示例的内容，通过源码分析，一步步带大家读懂AOP的原理实现。</p><h1 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h1><p>以下代码不以文字形式展示，若需要代码，可以到github查看完整Demo。<br>Demo：<a href="https://github.com/Zack-Ku/spring-aop-demo" target="_blank" rel="noopener">https://github.com/Zack-Ku/spring-aop-demo</a></p><p>Spring项目依然是用xml最原始的配置方式，为了只是能简单地阅读原理，否则会多很多自动配置的内容在里面。而AOP的配置用的是注解形式，因为毕竟看起来毕竟清晰，容易理解逻辑。</p><p>创建一个Gradle项目，添加对应的Spring与AOP的依赖。<br>（Gradle和Maven类似，都是自动化构建的工具。但与Maven相比，Gradle是基于groovy，采用DSL格式，具有更强的灵活性、简洁性、拓展性。现在连Spring的官方源码都是用Gradle的，可以说是一款面向未来的工具，后续也值得我们深入学习。）<br><img src="http://qiniu.zackku.com/image/java-spring-aop/gradle.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>创建一个Bean，TestBean。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/test-bean-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>创建AOP的Aspect。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/log-aspect.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>然后写一个启动类，测试以上配置<br><img src="http://qiniu.zackku.com/image/java-spring-aop/starter.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>运行结果：</p><blockquote><p>com.zack.demo.TestBean.getStr()开始执行…<br>getStr():Testing!<br>com.zack.demo.TestBean.getStr()方法结束…</p></blockquote><p>Demo：<a href="https://github.com/Zack-Ku/spring-aop-demo" target="_blank" rel="noopener">https://github.com/Zack-Ku/spring-aop-demo</a></p><h1 id="示例解析与AOP术语概念"><a href="#示例解析与AOP术语概念" class="headerlink" title="示例解析与AOP术语概念"></a>示例解析与AOP术语概念</h1><p>看到上面的结果，很容易猜想到，LogAspect作用了在TestBean上，使得每次执行TestBean上的方法时，都会执行对应的方法（before/after）。</p><p>LogAspect中带注解@Pointcut的allMethod()，是用来扫描程序中的连接点。当执行一个方法时，命中了连接点，则会根据不同的通知，执行对应的织入代码。在上面例子中，执行getStr()前会执行LogAspect中的before()，执行getStr()后会执行LogAspect中的after()。</p><p>具体的通知包含</p><ul><li>@Before，前置通知，执行方法前执行</li><li>@AfterReturn，返回通知，正常返回方法后执行</li><li>@After，后置通知，方法最终结束后执行，相当于finaly</li><li>@Around，环绕通知，围绕整个方法</li><li>@AfterThrowing，异常通知，抛出异常后执行</li></ul><p>开发者在命中连接点时，可以通过以上不同的通知，执行对应方法。这就是AOP中的Advisor。</p><p>以上的内容其实已经把AOP核心的概念都已经点出来了，我们再深入具体的认识下其中的术语，</p><ul><li>Aspect，切面，一个关注点的模块。<br>  例子中，LogAspect就是切面。</li><li>JoinPoint， 连接点，程序执行中的某个点，某个位置。<br>  例子中，testBean.getStr()是连接点。</li><li>PointCut，切点，切面匹配连接点的点，一般与切点表达式相关，就是切面如何切点。<br>  例子中，@PointCut注解就是切点表达式，匹配对应的连接点</li><li>Advice，通知，指在切面的某个特定的连接点上执行的动作。<br>  例子中，before()与after()方法中的代码。</li><li>TargetObject，目标对象，指被切入的对象。<br>  例子中，从ctx中取出的testBean则是目标对象。</li><li>Weave，织入，将Advice作用在JoinPoint的过程。</li></ul><p>以上概念看起来可以还比较难懂，可以通过以下一图（来源于网络）来理解<br><img src="http://qiniu.zackku.com/image/java-spring-aop/concept.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>请各位读者和各位程序员，在阅读源码的时候，一定要先搞清楚基本概念，和一定一定要知道对应概念的英文，否则在看源码的时候，根本对不上号，使理解难度大大提高。因为源码都是英文写的。</p><p>至此AOP的基本使用和概念相信大家都有一定的了解，下面开始从源码入手，去探索整个Spring AOP的实现。</p><h1 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h1><p>上面的例子之所以能完成AOP的代理，只因为Spring的xml配置里面加了这一句</p><blockquote><p>&lt; aop : aspectj-autoproxy / ></p></blockquote><p>加上了这一个配置，使得整个Spring项目拥有了AOP的功能。全局搜索下aspectj-autoproxy这个字段，可以发现，是这个类AspectJAutoProxyBeanDefinitionParser解析了这个元素。</p><p>其中的parse方法调用的是AopNamespaceUtils类中的registerAspectJAnnotationAutoProxyCreatorIfNecessary。这个方法作用是初始化一个AOP专用的Bean，并且注册到Spring容器中。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>解析这三个操作，</p><ol><li>第一句，注册一个AnnotationAwareAspectJAutoProxyCreator（称它为自动代理器），这个Creator是AOP的操作核心，也是扫描Bean，代理Bean的操作所在。</li><li>第二句，解析配置元素，决定代理的模式。其中有JDK动态代理，还有CGLIB代理，这部分后续会再细讲。</li><li>第三句，作为系统组件，把Creator这个Bean，放到Spring容器中。让Spring实例化，启动这个Creator。</li></ol><h2 id="自动代理器"><a href="#自动代理器" class="headerlink" title="自动代理器"></a>自动代理器</h2><p>下面我们来细看AnnotationAwareAspectJAutoProxyCreator是怎么对Bean做AOP的。</p><p>AnnotationAwareAspectJAutoProxyCreator的父类AbstractAutoProxyCreator，里面实现了BeanPostProceesor接口的postProcessAfterInitialization方法（该方法在一个Bean加载到Spring后会执行）。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>关联注释描述可知，当一个bean加载完后，执行了该方法，会生成一个新的代理对象，返回context中加载。</p><p>下面重点看其中的wrapIfNecessary方法。讲述了整个AOP的核心流程，是Spring AOP最最最核心的代码所在。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>看到红框的两个核心方法，可以知道，先从刚加载的Bean中扫描出所有的advice和advisor，然后用它来创建一个代理对象。</p><h2 id="获取Advisor"><a href="#获取Advisor" class="headerlink" title="获取Advisor"></a>获取Advisor</h2><p>先看如何扫描出advice和advisor。<br>一步步Debug getAdvicesAndAdvisorsForBean()，找到BeanFactoryAspectJAdvisorsBuilder中的buildAspectJAdvisors方法。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>该方法就是找出Spring容器中存在的AspectBean，然后返回所有AspectBean中的Advisor。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>示例中，LogAspect就是AspectBean，然后LogAspect中的before和after方法就是Advisor。<br>所以最终返回了LogAspect中的Advisor（before和after）。</p><h2 id="创建代理"><a href="#创建代理" class="headerlink" title="创建代理"></a>创建代理</h2><p>拿到了所有的Advisor后，就进入了创建代理的流程了createProxy()。<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这些入参，对比上一篇讲过的动态代理，其实非常相似。</p><ul><li>beanClass，加载到Spring，触发AOP的bean类</li><li>targetSource，目标对象，示例中则是从ctx中取出的testBean</li><li>specificInterceptors，指定Advisor，示例中则是before和after的方法。</li></ul><p>下面来具体看下代理的过程<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>代码可以概括为，创建一个proxyFactory对象，然后把上面的参数都丢到这个这个工厂里，最后从proxyFactory获取一个代理对象。</p><p>来看看ProxyFactory的getProxy方法是怎么生成代理对象的。</p><p>Debug该方法，可以在DefaultAopProxyFactory中createAopProxy看到<br><img src="http://qiniu.zackku.com/image/java-spring-aop/code-8.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>工厂会根据配置与目标对象的类型，选择用JDK动态代理（参考<a href="/java-dynamic-proxy">《你真的完全了解Java动态代理吗？看这篇就够了》</a>）还是CGLIB的代理（CGLIB具体在后续讲）。</p><p>代理后的对象放回ctx中，然后当程序执行的时候，会直接调用这个代理类。</p><p>至此整个AOP的代理流程就结束了。下面来了解下CGLIG代理与JDK代理的不同</p><h1 id="CGLIB与JDK代理区别"><a href="#CGLIB与JDK代理区别" class="headerlink" title="CGLIB与JDK代理区别"></a>CGLIB与JDK代理区别</h1><p>CGLIB（Code Generation Library）是一个强大的，高性能，高质量的Code生成类库。它可以在运行期扩展Java类与实现Java接口。Hibernate支持它来实现PO(Persistent Object 持久化对象)字节码的动态生成。</p><p>回顾下JDK代理，JDK代理需要一组需要实现的接口，然后通过这些接口获取构造方法，用这个构造方法和InvocationHandler，实例化一个对象出来。所以JDK的方式是基于接口的。</p><p>而CGLIB的代理是基于类的，用目标类生成一个子类，子类重写父类的方法，从而达到动态代理的效果。CGLIB的使用和实现等后面有机会再详细介绍。目前暂时只要理解两者不同的使用场景就足够了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下Spring AOP的流程</p><ol><li>Spring加载自动代理器AnnotationAwareAspectJAutoProxyCreator，当作一个系统组件。</li><li>当一个bean加载到Spring中时，会触发自动代理器中的bean后置处理</li><li>bean后置处理，会先扫描bean中所有的Advisor</li><li>然后用这些Adviosr和其他参数构建ProxyFactory</li><li>ProxyFactory会根据配置和目标对象的类型寻找代理的方式（JDK动态代理或CGLIG代理）</li><li>然后代理出来的对象放回context中，完成Spring AOP代理</li></ol><p>相信大家通过阅读本文，对Spring的AOP处理有一定的认识。想更深入地了解，探索每一步，每一行代码的实现，可以下载Demo源码，一步步地调试<br>Demo：<a href="https://github.com/Zack-Ku/spring-aop-demo" target="_blank" rel="noopener">https://github.com/Zack-Ku/spring-aop-demo</a></p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/spring-aop/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你真的完全了解Java动态代理吗？看这篇就够了</title>
      <link>http://zackku.com/java-dynamic-proxy/</link>
      <guid>http://zackku.com/java-dynamic-proxy/</guid>
      <pubDate>Fri, 07 Sep 2018 08:52:09 GMT</pubDate>
      <description>
      
        &lt;p&gt;之前讲了&lt;a href=&quot;/spring-ioc&quot;&gt;《零基础带你看Spring源码——IOC控制反转》&lt;/a&gt;，本来打算下一篇讲讲Srping的AOP的，但是其中会涉及到Java的动态代理，所以先单独一篇来了解下Java的动态代理到底是什么，Java是怎么实现它的。&lt;/p&gt;
&lt;p&gt;动态代理看起来好像是个什么高大上的名词，但其实并没有那么复杂，直接从字面就很容易理解。动态地代理，可以猜测一下它的含义，在运行时动态地对某些东西代理，代理它做了其他事情。先不去搞清楚这个动态代理真正的含义，我们来举个生动的例子来理解下它到底做了什么。&lt;/p&gt;
&lt;h1 id=&quot;一个例子&quot;&gt;&lt;a href=&quot;#一个例子&quot; class=&quot;headerlink&quot; title=&quot;一个例子&quot;&gt;&lt;/a&gt;一个例子&lt;/h1&gt;&lt;p&gt;一个程序员&lt;strong&gt;Developer&lt;/strong&gt;，他会开发code，他调试debug。&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-dynamic-proxy/code-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;br&gt;程序员有很多分类，其中有Java程序员&lt;strong&gt;JavaDeveloper&lt;/strong&gt;，他会开发Java代码，会调试Java代码。
      
      </description>
      
      <content:encoded><![CDATA[<p>之前讲了<a href="/spring-ioc">《零基础带你看Spring源码——IOC控制反转》</a>，本来打算下一篇讲讲Srping的AOP的，但是其中会涉及到Java的动态代理，所以先单独一篇来了解下Java的动态代理到底是什么，Java是怎么实现它的。</p><p>动态代理看起来好像是个什么高大上的名词，但其实并没有那么复杂，直接从字面就很容易理解。动态地代理，可以猜测一下它的含义，在运行时动态地对某些东西代理，代理它做了其他事情。先不去搞清楚这个动态代理真正的含义，我们来举个生动的例子来理解下它到底做了什么。</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><p>一个程序员<strong>Developer</strong>，他会开发code，他调试debug。<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>程序员有很多分类，其中有Java程序员<strong>JavaDeveloper</strong>，他会开发Java代码，会调试Java代码。<a id="more"></a><br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>但是呢，有个叫Zack的程序员它在开发之前，会祈祷一下，这样他开发的代码就不会有bug。</p><p>Zack的这种“特异功能”是后天练出来的，并没有哪种程序员有这种特性。虽然我们也可以定义一个拥有这样特性的程序员，但是拥有各种乱七八糟特性的程序千千万。我们什么时候才能定义完，而能保证不漏呢？</p><p>其实我们没有必要去定义他，因为他是后天养成的，我们应该在这个程序员的成长期去实现这个特性，而不是在他出生之前定义。</p><p>我们来看下代码是怎么实现的<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>如果Zack只是一个普通的Java程序员，那么他的开发结果是<br>Zack is coding java<br>Zack is debugging java</p><p>但是真正的Zack（代理后）<br>Zack is praying for the code!<br>Zack is coding java<br>Zack’s have no bug！No need to debug!</p><h1 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance()"></a>Proxy.newProxyInstance()</h1><p>回看下上面是如何使用动态代理的使用。生成一个实例对象，然后用Proxy的newInstance方法对这个实例对象代理生成一个代理对象。<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这里有一个非常关键的人，也是比较少人去理解它的。为什么要传zack的类加载和zack的接口呢？<br>有没有留意到zackProxy的类型是Developer接口，而不是一个实现类。因为zack在被代理后生成的对象，并不属于Developer接口的任何一个实现类。但是它是基于Developer接口和zack的类加载代理出来的。</p><p>看下newProxyInstance()的接口定义<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这三个参数具体的含义来看看注解是怎么描述的<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/proxy-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ul><li>loder，选用的类加载器。因为代理的是zack，所以一般都会用加载zack的类加载器。</li><li>interfaces，被代理的类所实现的接口，这个接口可以是多个。</li><li>h，绑定代理类的一个方法。</li></ul><p>loder和interfaces基本就是决定了这个类到底是个怎么样的类。而h是InvocationHandler，决定了这个代理类到底是多了什么功能。所以动态代理的内容重点就是这个InvocationHandler。</p><h1 id="InvocationHandler"><a href="#InvocationHandler" class="headerlink" title="InvocationHandler"></a>InvocationHandler</h1><p><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/proxy-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>根据注解描述可知，InvocationHandler作用就是，当代理对象的原本方法被调用的时候，会绑定执行一个方法，这个方法就是InvocationHandler里面定义的内容，同时会替代原本方法的结果返回。</p><p>InvocationHandler接收三个参数</p><ul><li>proxy，代理后的实例对象。</li><li>method，对象被调用方法。</li><li>args，调用时的参数。</li></ul><p>在上面的例子里，<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>如果最后的return语句改成<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return method.invoke(proxy, agrs);</span><br></pre></td></tr></table></figure></p><p>invoke的对象不是zack，而是proxy，根据上面的说明猜猜会发生什么？<br>是的，会不停地循环调用。因为proxy是代理类的对象，当该对象方法被调用的时候，会触发InvocationHandler，而InvocationHandler里面又调用一次proxy里面的对象，所以会不停地循环调用。并且，proxy对应的方法是没有实现的。所以是会循环的不停报错</p><h1 id="动态代理的原理"><a href="#动态代理的原理" class="headerlink" title="动态代理的原理"></a>动态代理的原理</h1><p>通过上面的讲解，相信大家对动态代理的使用理解得比较深刻了。那动态代理到底是怎么实现的呢，我们来看看源码其中关键的地方。<br>在newProxyInstance()发放中有这样几段。<br><img src="http://qiniu.zackku.com/image/java-dynamic-proxy/code-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>其实大概就是把接口复制出来，通过这些接口和类加载器，拿到这个代理类cl。然后通过反射的技术复制拿到代理类的构造函数（这部分代码在Class类中的getConstructor0方法），最后通过这个构造函数new个一对象出来，同时用InvocationHandler绑定这个对象。</p><h1 id="动态代理的使用场景"><a href="#动态代理的使用场景" class="headerlink" title="动态代理的使用场景"></a>动态代理的使用场景</h1><p>动态代理的好处我们从例子就能看出来，它比较灵活，可以在运行的时候才切入改变类的方法，而不需要预先定义它。</p><p>动态代理一般我们比较少去手写，但我们用得其实非常多。在Spring项目中用的注解，例如依赖注入的@Bean、@Autowired，事务注解@Transactional等都有用到，换言之就是Srping的AOP（切面编程）。</p><p>这种场景的使用是动态代理最佳的落地点，可以非常灵活地在某个类，某个方法，某个代码点上切入我们想要的内容，就是动态代理其中的内容。所以下一篇我们来细致了解下Spring的AOP到底是怎么使用动态代理的。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-dynamic-proxy/#disqus_thread</comments>
    </item>
    
    <item>
      <title>零基础带你看Spring源码——IOC控制反转</title>
      <link>http://zackku.com/spring-ioc/</link>
      <guid>http://zackku.com/spring-ioc/</guid>
      <pubDate>Mon, 03 Sep 2018 14:09:54 GMT</pubDate>
      <description>
      
        &lt;p&gt;本章开始来学习下Spring的源码，看看Spring框架最核心、最常用的功能是怎么实现的。&lt;br&gt;网上介绍Spring，说源码的文章，大多数都是生搬硬推，都是直接看来的观点换个描述就放出来。这并不能说有问题，但没有从一个很好的、容易切入的角度去了解学习。博主来尝试抛弃一些所知，从使用上入手，步步回溯源码去了解学习。&lt;/p&gt;
&lt;p&gt;很多人会混乱IOC和DI的两个概念，其实这两者是层面的不同。&lt;br&gt;具体的区别的区别：&lt;strong&gt;IOC是DI的原理。依赖注入是向某个类或方法注入一个值，其中所用到的原理就是控制反转。&lt;/strong&gt;&lt;br&gt;所以说到操作层面的时候用DI，原理层的是说IOC，下文亦同。&lt;/p&gt;
&lt;p&gt;对于DI最新使用方法，现在都是建议用Java注解去标识。但是相信笔者，不要用这种方式去看源码。笔者本来是想从Java注解入手去一步步看源码，debug看看发生什么了。但发现更多时间是在调SpringBoot和AOP的源码。在看了一天后，还是换一种思路吧，因为AOP是打算在下一章再讲的。&lt;/p&gt;
&lt;p&gt;所以我用XML的方式，搭了一个最简单的Spring项目来学习其中IOC的源码。建议大家把代码拉下来，跟着笔者思路来一起看。&lt;br&gt;源码在此：&lt;a href=&quot;https://github.com/Zack-Ku/spring-ioc-demo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Zack-Ku/spring-ioc-demo&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;搭建内容&quot;&gt;&lt;a href=&quot;#搭建内容&quot; class=&quot;headerlink&quot; title=&quot;搭建内容&quot;&gt;&lt;/a&gt;搭建内容&lt;/h1&gt;&lt;p&gt;maven的依赖,只添加了spring-context模板，用的是4.3.11版本
      
      </description>
      
      <content:encoded><![CDATA[<p>本章开始来学习下Spring的源码，看看Spring框架最核心、最常用的功能是怎么实现的。<br>网上介绍Spring，说源码的文章，大多数都是生搬硬推，都是直接看来的观点换个描述就放出来。这并不能说有问题，但没有从一个很好的、容易切入的角度去了解学习。博主来尝试抛弃一些所知，从使用上入手，步步回溯源码去了解学习。</p><p>很多人会混乱IOC和DI的两个概念，其实这两者是层面的不同。<br>具体的区别的区别：<strong>IOC是DI的原理。依赖注入是向某个类或方法注入一个值，其中所用到的原理就是控制反转。</strong><br>所以说到操作层面的时候用DI，原理层的是说IOC，下文亦同。</p><p>对于DI最新使用方法，现在都是建议用Java注解去标识。但是相信笔者，不要用这种方式去看源码。笔者本来是想从Java注解入手去一步步看源码，debug看看发生什么了。但发现更多时间是在调SpringBoot和AOP的源码。在看了一天后，还是换一种思路吧，因为AOP是打算在下一章再讲的。</p><p>所以我用XML的方式，搭了一个最简单的Spring项目来学习其中IOC的源码。建议大家把代码拉下来，跟着笔者思路来一起看。<br>源码在此：<a href="https://github.com/Zack-Ku/spring-ioc-demo" target="_blank" rel="noopener">https://github.com/Zack-Ku/spring-ioc-demo</a></p><h1 id="搭建内容"><a href="#搭建内容" class="headerlink" title="搭建内容"></a>搭建内容</h1><p>maven的依赖,只添加了spring-context模板，用的是4.3.11版本<a id="more"></a>（部分代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;4.3.11.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></p><!-- ![](http://qiniu.zackku.com/image/java-spring-ioc/dependency.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim) --><p>作为Bean的Service（部分代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class TestBeanServiceImpl implements TestBeanService &#123;</span><br><span class="line">    public String getBean() &#123;</span><br><span class="line">        return &quot;a test bean&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- ![](http://qiniu.zackku.com/image/java-spring-ioc/beanservice-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim) --><p>配置XML（部分代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;testBeanService&quot; class=&quot;com.zack.demo.TestBeanServiceImpl&quot;/&gt;</span><br></pre></td></tr></table></figure></p><!-- ![](http://qiniu.zackku.com/image/java-spring-ioc/xml.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim) --><p>启动类。只是加载了下spring的xml配置，然后从context中拿出Bean，这就是完整IOC的过程了。（部分代码）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 加载xml配置</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">            new ClassPathXmlApplicationContext(&quot;classpath:application.xml&quot;);</span><br><span class="line"></span><br><span class="line">        // IOC获取Bean</span><br><span class="line">        TestBeanService testBeanService = context.getBean(TestBeanService.class);</span><br><span class="line"></span><br><span class="line">        System.out.println(testBeanService.getBean());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><!-- ![](http://qiniu.zackku.com/image/java-spring-ioc/application.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim) --><p>最后启动就能获取这个bean，看到getMessage()打印的内容了。</p><p>这样就是一个比较纯粹的Spring-IOC的项目了。我们直接从启动类开始看起</p><h1 id="Bean的含义"><a href="#Bean的含义" class="headerlink" title="Bean的含义"></a>Bean的含义</h1><p>前置先解释下这个Bean的含义，因为会贯穿整个流程。<br>通俗地讲，Bean就是IOC的容器。如上面的例子，将TestBeanService注册到Spring里，那么TestBeanService就是Spring的里面的一个Bean。Demo里面<code>context.getBean()</code>就是从Spring中取出这个Bean，完成控制反转的。</p><p>所以我们的重点就是要看看Spring到底是怎么生成管理这些Bean的。</p><h1 id="ClassPathXmlApplicationContext"><a href="#ClassPathXmlApplicationContext" class="headerlink" title="ClassPathXmlApplicationContext"></a>ClassPathXmlApplicationContext</h1><p>启动类中，加载配置的<code>ClassPathXmlApplicationContext</code>肯定就是完成IOC的核心。不知道它到底是怎么做的，怎么入手呢？<br>先来看看它的类图<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>先分析下这个类图，</p><ol><li><code>ClassPathXmlApplicationContext</code>类是<code>AbstractApplicationContext</code>抽象类的子类</li><li><code>AbstractApplicationContext</code>类是<code>ApplicaionContext</code>接口的实现。</li><li><code>ApplicaionContext</code>接口集合了非常多的内容，其中和IOC比较相关的就是<code>ListableBeanFactory</code>接口和<code>HierarchicalBeanFactory</code>接口</li><li><code>ListableBeanFactory</code>接口和<code>HierarchicalBeanFactory</code>接口是继承<code>BeanFactory</code></li></ol><p>从此分析可以看出，<code>ClassPathXmlApplicationContext</code>是什么，了解下<code>ApplicaionContext</code>；它怎么和IOC有关，要了解<code>BeanFactory</code>。<br>所以后面我们先来看看<code>ApplicaionContext</code>与<code>BeanFactory</code>。</p><h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><p><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从该接口的注解描述可知，ApplicationContext是整个项目的配置，Spring项目在启动或运行的时候都需要依赖到它。</p><p>其中Bean管理相关的则是<code>ListableBeanFactory</code>和<code>HierarchicalBeanFactory</code>。</p><h1 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h1><p><code>ListableBeanFactory</code>和<code>HierarchicalBeanFactory</code>都是继承<code>BeanFactory</code>的。<br>先看看<code>BeanFactory</code>的文件注解<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/bean-factory-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从上图可知，<code>BeanFactory</code>就是获取Bean容器的地方。而且他可以提供单例的对象或者是独立的对象</p><p><img src="http://qiniu.zackku.com/image/java-spring-ioc/bean-factory-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从这段可以得知，<code>HierarchicalBeanFactory</code>是一个分层的Bean，如果实现了这个接口，所有方法都会经过父类的工厂。所以这个是个拓展的类，暂时先不看它。</p><p>接下来看看<code>ListableBeanFactory</code>注解说明<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/bean-factory-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个接口是要实现预先加载Bean的配置，生成好实例，直接管理Bean的实例，而不是来一个请求，生成一个。</p><p>好了，以上就是基本的概念和认知，现在带着这些概念，我们回头看看<code>ClassPathXmlApplicationContext</code>的执行流程，看看它到底怎么的生成管理Bean的。</p><h1 id="初始化IOC容器"><a href="#初始化IOC容器" class="headerlink" title="初始化IOC容器"></a>初始化IOC容器</h1><p>从<code>ClassPathXmlApplicationContext</code>的构造函数看，最核心的就是<code>refresh()</code>函数，其他只是设一些值。<br>而这个<code>refresh()</code>是调用父类<code>AbstractApplicationContext</code>中的<code>refresh()</code>。<br>根据它的注解可知它是加载刷新了整个context，并且加载所有Bean定义和创建对应的单例。<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>看下这个方法做了什么<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>里面有许多步骤，重点看下<code>obtainFreshBeanFactory()</code>（重新获取一个BeanFactory）。<br>它里面有个核心的方法<code>refreshBeanFactory()</code><br><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>如果已有BeanFactory，先删除所有Bean，然后关闭BeanFactory。<br>然后创建一个新的<code>ListableBeanFactory</code>，上面说到这个工厂里会预先加载所有的Bean。<br>最后核心的就是<code>loadBeanDefinitions(beanFactory)</code>，它是加载Bean的定义。实现交给了子类。<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/context-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>用的是<code>XmlBeanDefinitionReader</code>直接读配置文件加载Bean Definition(Bean定义)到BeanFactory。它里面一步步把xml的配置文件拆解读取，把一个个Bean Definition加载到BeanFactory里。<br>至此，已经有用一个加载好Bean Definition的BeanFactory了。</p><p>其他方法也是围绕BeanFactory后置处理和Context的配置准备。内容太多，想更深入了解的话建议顺着以上思路，找到对应代码阅读以下。</p><h1 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h1><p>回到启动类中，看看怎么从context中获取bean的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context.getBean(TestBeanService.class)</span><br></pre></td></tr></table></figure></p><p>是根据类去拿bean的，当然也可以根据id。<br>其对应的源码实现，在<code>DefaultListableBeanFactory</code>中，上文有说到对应的BeanFactory选型。<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/get-bean-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><code>NamedBeanHolder</code>是里面包含一个实例化的对象，和bean的名字。<code>resolveNamedBean()</code>是怎么拿出Bean的关键。</p><p>一步步Debug，可以看到，它是遍历BeanFactory里面维护的beanDefinitionNames和manualSingletonNames成员变量，找出命中的beanName返回。<br><img src="http://qiniu.zackku.com/image/java-spring-ioc/get-bean-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>然后拿着这个beanName去找具体的bean实例。这里的代码比较长，在<code>AbstractBeanFactory</code>里面的<code>doGetBean()</code>中实现。<br>大意是先尝试去找手动添加bean的单例工厂里找有没有对应的实例，没有的话就往父类beanFactory里面找，最后没有的话就生成一个。</p><p>spring中一个bean是如何加载和如何注入大致如此，更细节的内容，可以自己debug看看源码。</p><h1 id="控制反转的优点"><a href="#控制反转的优点" class="headerlink" title="控制反转的优点"></a>控制反转的优点</h1><p>最后来以我个人观点谈谈控制反转的优点吧。<br>举个例子，我要装修房子，需要门、浴具、厨具、油漆、玻璃等材料。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decorateHouse(Door,BathThing,CookThing,....)</span><br></pre></td></tr></table></figure></p><p>但是我作为一个装修工人，我需要去制造门、制造浴具，合成玻璃油漆吗？<br>不需要，也不关心其建造的过程，对应的会有人去做这些东西。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">door = buildDoor();</span><br><span class="line">glass = buildGlass();</span><br></pre></td></tr></table></figure></p><p>所有材料放到建材商城里面，装修工人需要什么材料就去建材商城里面取。</p><p>对应Spring的IOC，门、玻璃等材料就是Bean，建材商城就是IOC容器，把材料放到建材商城就是Bean加载，去商城拿材料就是依赖注入的过程。</p><p>程序开发发展至今，一个简答的项目或许也要分几个模板，几个人去开发。划分好职责，设计好接口，面向接口编程。每个人只需要完成好自己那部分的工作，依赖调用就可以了。这样做同时有助于降低项目的耦合度，让项目有更好的延伸性。由此Spring的IOC就是基于以上的需求所诞生的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下全文的内容</p><ol><li>ApplicationContext是Spring项目的核心配置，项目运行依赖于它，其中包含许多方面的内容。</li><li>BeanFactory是Context包含的内容之一，它负责管理Bean的加载，生成，注入等内容。</li><li>Spring控制反转为了降低项目耦合，提高延伸性。</li></ol><p>本文讲Spring IOC还比较浅显，仅仅讲了如何加载的重点和注入的重点，关于生命周期，BeanFactory的处理由于篇幅问题并没有细讲。有兴趣的读者可以用Demo跑起来，一步步Debug看看。因为Demo基本是最小化的Spring IOC了，所以这个Debug不会太难，很容易就能看清楚整个流程做了什么。</p><p>Demo：<a href="https://github.com/Zack-Ku/spring-ioc-demo" target="_blank" rel="noopener">https://github.com/Zack-Ku/spring-ioc-demo</a></p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/spring-ioc/#disqus_thread</comments>
    </item>
    
    <item>
      <title>你真的懂ThreadPoolExecutor线程池技术吗？看了源码你会有全新的认识</title>
      <link>http://zackku.com/java-thread-threadpoolexecutor/</link>
      <guid>http://zackku.com/java-thread-threadpoolexecutor/</guid>
      <pubDate>Tue, 28 Aug 2018 09:12:58 GMT</pubDate>
      <description>
      
        &lt;p&gt;Java是一门多线程的语言，基本上生产环境的Java项目都离不开多线程。而线程则是其中最重要的系统资源之一，如果这个资源利用得不好，很容易导致程序低效率，甚至是出问题。&lt;/p&gt;
&lt;p&gt;有以下场景，有个电话拨打系统，有一堆需要拨打的任务要执行，首先肯定是考虑多线程异步去执行。假如我每执行一个拨打任务都new一个Thread去执行，当同时有1万个任务需要执行的时候，那么就会新建1万个线程，加上线程各种初始销毁等操作，这个消耗是巨大的。而其实往往实现这些功能的时候，并不是完全需要实时马上完成，只是希望在可控范围内尽量提高执行的并发性能。&lt;/p&gt;
&lt;p&gt;因此线程池技术应用而生，Java中最常用的线程池技术就是ThreadPoolExecutor。接下来就整体看看ThreadPoolExecutor的实现。
      
      </description>
      
      <content:encoded><![CDATA[<p>Java是一门多线程的语言，基本上生产环境的Java项目都离不开多线程。而线程则是其中最重要的系统资源之一，如果这个资源利用得不好，很容易导致程序低效率，甚至是出问题。</p><p>有以下场景，有个电话拨打系统，有一堆需要拨打的任务要执行，首先肯定是考虑多线程异步去执行。假如我每执行一个拨打任务都new一个Thread去执行，当同时有1万个任务需要执行的时候，那么就会新建1万个线程，加上线程各种初始销毁等操作，这个消耗是巨大的。而其实往往实现这些功能的时候，并不是完全需要实时马上完成，只是希望在可控范围内尽量提高执行的并发性能。</p><p>因此线程池技术应用而生，Java中最常用的线程池技术就是ThreadPoolExecutor。接下来就整体看看ThreadPoolExecutor的实现。<a id="more"></a><br>这个类的注解非常多，很多也是重点，所以就不从注解开始看起。先从使用说起，有个概念先。</p><h1 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 核心线程</span><br><span class="line">int corePoolSize = 5;</span><br><span class="line">// 最大线程</span><br><span class="line">int maximumPoolSize = 10;</span><br><span class="line">// 线程空闲回收时间</span><br><span class="line">int keepAliveTime = 30;</span><br><span class="line">// 线程空闲回调时间单位</span><br><span class="line">TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">// 队列大小</span><br><span class="line">int queueSize = 20;</span><br><span class="line">// 队列</span><br><span class="line">BlockingQueue workQueue = new ArrayBlockingQueue&lt;Runnable&gt;(queueSize);</span><br><span class="line">ThreadPoolExecutor executor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);</span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    // do something 1</span><br><span class="line">&#125;);</span><br><span class="line">executor.execute(() -&gt; &#123;</span><br><span class="line">    // do something 2</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>定义好一些必要的参数，构建一个ThreadPoolExecutor对象。然后调用对象的execute()方法即可。<br>参数说明：</p><ul><li>corePoolSize，线程池保留的最小线程数。如果线程池中的线程少于此数目，则在执行execut()时创建。</li><li>maximumPoolSize，线程池中允许拥有的最大线程数。</li><li>keepAliveTime、unit，当线程闲置时，保持线程存活的时间。</li><li>workQueue，工作队列，存放提交的等待任务，其中有队列大小的限制。</li></ul><h1 id="线程管理机制"><a href="#线程管理机制" class="headerlink" title="线程管理机制"></a>线程管理机制</h1><p><strong>非常多人误解了corePoolSize、maximumPoolSize、workQueue的相互关系。不少人认为无论队列选择什么，corePoolSize和maximumPoolSize一定是有用，定义一定是生效的，其实并不然啊!</strong><br>看下<strong>线程基本规则</strong>注解说明<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/queues-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ol><li>默认情况下，线程池在初始的时候，线程数为0。当接收到一个任务时，如果线程池中存活的线程数小于corePoolSize核心线程，则新建一个线程。</li><li>如果所有运行的核心线程都都在忙，超出核心线程处理的任务，执行器更多地选择把任务放进队列，而不是新建一个线程。</li><li>如果一个任务提交不了到队列，在不超出最大线程数量情况下，会新建线程。超出了就会报错。</li></ol><p>另外，如果想在线程初始化时候就有核心线程，可以调用prestartCoreThread()或prestartAllCoreThread()，前者是初始一个，后者是初始全部。</p><p>再看看<strong>排队策略</strong><br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/queues-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ul><li>直接提交，用SynchronousQueue。特点是不保存，直接提交给线程，如果没没线程，则新建一个。</li><li>无限提交，用类似LinkedBlockingQueue无界队列。特点是保存所以核心线程处理不了的任务，队列无上限，最大线程也没用。</li><li>有限提交，用类似ArrayBlockingQueue有界队列。特点是可以保存超过核心线程的任务，并且队列也是有上限的。超过上限，新建线程（满了抛错）。更好地保护资源，防止崩溃，也是最常用的排队策略。</li></ul><p><strong>从以上规则可以看出来，核心线程数和最大线程数，还有队列结构是相互影响的，如何排队，队列多大，最大线程是多少都是不一定的。</strong></p><p>再看看<strong>保持存活机制</strong><br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/keepalive-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>当超过核心线程数的线程，线程池会让该线程保持存活keepAliveTime时间，超过该时间则会销毁该线程。<br>另外默认对非核心线程有效，若想核心线程也适用于这个机制，可以调用allowCoreThreadTimeOut()方法。这样的话就没有核心线程这一说了。</p><p><strong>综合以上，线程池在多次执行任务后，会一直维持部分线程存活，即使它是闲置的。这样的目的是为了减少线程销毁创建的开销，下次有个任务需要执行，直接从池子里拿线程就能用了。但核心线程不能维护太多，因为也需要一定开销。最大的线程数保护了整个系统的稳定性，避免并发量大的时候，把线程挤满。工作队列则是保证了任务顺序和暂存，系统的可靠性。线程存活规则的目的和维护核心线程的目的类似，但降低了它的存活的时间。</strong></p><p>另外还有<strong>拒绝机制</strong>，它提供了一些异常情况下的解决方案。<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/reject-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h1 id="ctl线程状态控制"><a href="#ctl线程状态控制" class="headerlink" title="ctl线程状态控制"></a>ctl线程状态控制</h1><p>这个ctl变量是整个线程池的核心控制状态。<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/execute-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个ctl代表了两个变量</p><ul><li>workerCount，生效的线程数。基本可以理解为存活的线程，但某个时候有暂时性的差异。</li><li>runState，线程池的运行状态。<br>其中，ctl（int32位）的低29位代表workerCount，所以最大线程数为(2^29)-1。另外3位表示runState。</li></ul><p>runState有以下几种状态：<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/execute-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ul><li>RUNNING：接收新任务，处理队列任务。</li><li>SHUTDOWN：不接收新任务，但处理队列任务。</li><li>STOP：不接收新任务，也不处理队列任务，并且中断所有处理中的任务。</li><li>TIDYING：所有任务都被终结，有效线程为0。会触发terminated()方法。</li><li>TERMINATED：当terminated()方法执行结束。</li></ul><p>当调用了shutdown()，状态会从RUNNING变成SHUTDOWN，不再接收新任务，此时会处理完队列里面的任务。<br>如果调用的是shutdownNow()，状态会直接变成STOP。<br>当线程或者队列都是空的时候，状态就会变成TIDYING。<br>当terminated()执行完的时候，就会变成TERMINATED。</p><h1 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h1><p>带着对上面的规则与机制的认识，现在从就这这个入口开始看看源码，到底整个流程是怎么实现的。<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/execute-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><ol><li>如果少于核心线程在跑，用这个任务尝试创建一个新线程。</li><li>如果一个任务成功入队，再次检查下线程池状态看是否需要入队，因为可能在入队过程中，状态发送了变化。如果确认入队且没有存活线程，则新建一个空线程。</li><li>如果进不了队，则尝试新建一个线程，如果都失败了。拒绝这个task<br>对于第二点最后为什么新建一个线程？很容易猜想到，会有一个轮询的机制让下个task出队，直接利用这个空闲线程。</li></ol><p>注释基本解释了所有代码，代码也没什么特别的。其中最主要的还是addWoker()这个方法，下面来看看。</p><h1 id="addWoker"><a href="#addWoker" class="headerlink" title="addWoker()"></a>addWoker()</h1><p>先了解下这个方法的整体思路<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>从描述可知，addwoker失败，会在线程池状态不对、线程满了或者线程工厂创建线程池失败时候发生。<br>这个方法比较长，分两段看。先看第一段。<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><code>retry:</code>这种写法，如果比较少看源码的，应该是前所未见的了。这是个循环的位置标记，是java的语法之一。看回代码，这里面for循环还嵌套里一个for循环，而<code>retry:</code>是标记第一个for循环的，后面<code>break</code>和<code>continue</code>语句都指向到了<code>retry</code>。说明<code>break</code>和<code>continue</code>是都是操作外层的for循环。retry可以是任何变量命名合法的字符。</p><p>然后看看外出for循环的if语句<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个if判断想要执行到<code>return false;</code>，队列为空是一个必要条件。因为addWork()不单只接收新任务会调用到，处理队列中的任务也会调用到。而前面提到SHUTDOWN状态下还会处理队列中的任务的，所以队列不为空是会让它继续执行下去的。</p><p>对于内层的for循环<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>会先判断worker的数据是否符合corePoolSize和maximumPoolSize的定义，不满足则返回失败。<br>然后尝试CAS让workerCount自增，如果CAS失败还是继续自旋去自增，直到成功。除非线程池状态发生了变化，发退回到外层for循环重新执行，判断线程池的状态。</p><p><strong>第一段的代码，就是让workerCount在符合条件下自增</strong></p><p>第二段代码<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这段比较好理解，先创建一个Worker对象，这个Worker里面包含一个由线程工厂创建的线程，和一个需要执行的任务（可以为空）。如果线程创建成功了，那么就加一个重入锁去把这个新建的Worker对象放到workers成员变量中，在加入之前需要重新判断下线程池的状态和新建线程的状态。如果worker添加到workers成员变量中，就启动这个新建的线程。最后如果添加失败，则执行<code>addWorkFailed(w)</code>。<br><img src="http://qiniu.zackku.com/image/java-thread-threadpoolexecutor/addworker-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>如果失败了，加锁操作回滚下wokers、workerCount，然后判断下状态看看是否需要终结线程池。</p><p><code>addWorker()</code>大概的流程就这样。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>对于其他方法，没有什么特别的，在此不再过多的叙述，有兴趣的可以翻翻源码阅读下。<br>回顾总结下上面的核心要点</p><ol><li>当核心线程满且忙碌时，线程池倾向于把提交的任务放进队列，而不是新建线程。</li><li>根据选择队列的不同，maximumPoolSize不一定有用的。具体有三种不同的策略。</li><li>ctl是线程池的核心控制状态，包含的runState线程池运行状态和workCount有效线程数。</li><li><code>retry:</code>是一种标记循环的语法，retry可以是任何变量命名合法字符。</li></ol><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-threadpoolexecutor/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程——ReentrantReadWriteLock源码阅读</title>
      <link>http://zackku.com/java-thread-reentranreedwritelock/</link>
      <guid>http://zackku.com/java-thread-reentranreedwritelock/</guid>
      <pubDate>Sun, 26 Aug 2018 17:49:26 GMT</pubDate>
      <description>
      
        &lt;!-- 为什么要read write lock --&gt;
&lt;p&gt;之前讲了&lt;a href=&quot;/java-thread-aqs&quot;&gt;《AQS源码阅读》&lt;/a&gt;和&lt;a href=&quot;/java-thread-reentrantlock&quot;&gt;《ReentrantLock源码阅读》&lt;/a&gt;，本次将延续阅读下ReentrantReadWriteLock，建议没看过之前两篇文章的，先大概了解下，有些内容会基于之前的基础上阅读。&lt;br&gt;这个并不是ReentrantLock简单的升级，而是落地场景的优化，我们来详细了解下吧。&lt;/p&gt;
&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;JUC包里面已经有一个ReentrantLock了，为何还需要一个ReentrantReadWriteLock呢？看看头注解找点线索。&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;br&gt;它是ReadWriteLock接口的实现。那看看这个接口怎么说&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<!-- 为什么要read write lock --><p>之前讲了<a href="/java-thread-aqs">《AQS源码阅读》</a>和<a href="/java-thread-reentrantlock">《ReentrantLock源码阅读》</a>，本次将延续阅读下ReentrantReadWriteLock，建议没看过之前两篇文章的，先大概了解下，有些内容会基于之前的基础上阅读。<br>这个并不是ReentrantLock简单的升级，而是落地场景的优化，我们来详细了解下吧。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>JUC包里面已经有一个ReentrantLock了，为何还需要一个ReentrantReadWriteLock呢？看看头注解找点线索。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>它是ReadWriteLock接口的实现。那看看这个接口怎么说<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><a id="more"></a><br>在实际场景中，一般来说，读数据远比写数据要多。如果我们还是用独占锁去锁线程避免线程不安全的话，是非常低效的，而且同时也会失去它的并发性。多线程也没有意义了。所以ReadWriteLock就是解决这个问题所存在的。<br>看回ReentrantReadWriteLock的头注解。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>ReentrantReadWriteLock依然有公平锁/非公平锁的功能，与ReentrantLock不同在于，前者内部维护了读锁和写锁，在公平/非公平模式下，他们会一起去竞争这个锁资源。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>上图是两条ReentrantReadWriteLock最核心的规则。</p><ol><li>申请读锁。当没有其他写锁占有，或者读锁在队列中排队时间最长的，才能成功</li><li>申请写锁。当没有其他线程占有读/写锁的情况下，才能成功</li></ol><p>又以上两条规则可以推导出，</p><ol><li>写锁比读锁要高级</li><li>有读锁占用可以继续申请读锁，但其他线程不能申请写锁</li><li>有写锁占用其他线程读写都不能申请</li></ol><p>所以扣ReadWriteLock接口的说明，可以让读并发，写独占，提高了程序的并发性。</p><h1 id="ReentrantReadWriteLock构成"><a href="#ReentrantReadWriteLock构成" class="headerlink" title="ReentrantReadWriteLock构成"></a>ReentrantReadWriteLock构成</h1><p>看下ReentrantReadWriteLock的file struture<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>之前看过ReentrantLock源码的同学肯定很熟悉这个结构，看起来相同的都是Sync同步器（AQS的子类），以及它的两个公平/非公平子类。<br>不同的是它还多了ReadLock内部类和WriteLock内部类，以及读写对应的成员变量和方法。并且少了lock()、unlock()等方法，而是把加锁解锁的功能下方给这两个子类，符合ReadWriteLock接口的定义。</p><h1 id="Sync内部类"><a href="#Sync内部类" class="headerlink" title="Sync内部类"></a>Sync内部类</h1><p>虽然ReentrantReadWriteLock和ReentrantLock都有Sync，但其实Sync方法已经很大不同了，看下Sync的结构<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>对比之前ReentrantLock的Sync，最大不同在于它多了**shared()方法，用于共享锁的获取与释放。<br>另外tryReadLock()、tryWriteLock()是给WriteLock和ReadLock内部类使用的。</p><h2 id="tryAcquire-独占锁（写锁）申请"><a href="#tryAcquire-独占锁（写锁）申请" class="headerlink" title="tryAcquire() 独占锁（写锁）申请"></a>tryAcquire() 独占锁（写锁）申请</h2><p><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>上文介绍重入锁说到state代表的是重入的次数，在读写锁的语义下，state代表的读/写占有(重入)的次数。c为state，w为独占重入次数。<br>当有线程占用锁时（c!=0），如果没有写锁（w==0）或者独占线程不是当前线程，返回false获取失败。锁的重入总数超过上限会抛出异常。<br>这里很容易看出来，如果有锁占用的时候，如果只是读锁，依然可以申请成功。这就是读锁的<strong>锁升级</strong>。<br>当没有线程占用的时候，执行writerShouldBlock()判断是否需要阻塞线程（子类实现自己的条件），不需要则CAS state值，返回成功。</p><h2 id="tryAquireShared-共享锁（读锁）申请"><a href="#tryAquireShared-共享锁（读锁）申请" class="headerlink" title="tryAquireShared() 共享锁（读锁）申请"></a>tryAquireShared() 共享锁（读锁）申请</h2><p><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-8.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>读锁申请比写锁申请要复杂，有比较多没接触过的成员变量，判断的语句也比较多。<br>先看看成员变量，从他们各自的变量注解可知</p><ul><li>firstReader，是第一个获取读锁的线程</li><li>firstReaderHoldCount，是firstReader的计数器。</li><li>cachedHoldCounter，最近一个成功获取读锁的线程持有数计数器。</li><li>readHolds，当前线程重入读锁次数。<strong>ThreadLocal<holdcounter>，是线程安全的HoldCounter</holdcounter></strong>。</li></ul><p>先判断是否有写锁占有，如果写锁不是当前线程，获取读锁失败，退出方法。<br>注意如果写锁是当前线程是可以获取读锁的，因为写锁是独占的，这种情况下是不会有数据与其他线程共享的问题。<br>满足子类条件，也不超过总数，CAS也成功的情况下，<br>如果没有读锁，则设firstReader为当前线程，firstReaderHoldCount为1；<br>如果有读锁，并且也是当前线程申请获取，firstReaderHoldCount自增1；<br>如果有读锁，不是当前线程申请，取上一个成功的缓存计数器，如果这个计数器不是当前线程的，则设为当前的计数器，并且自增，返回成功。（其实就是把缓存计数器置换为当前线程的计数器）<br>最后不满足条件或者CAS失败，执行fullTryAcquireShared(current)返回。<br>至于这些数据算来干嘛，等后面看看release()怎么用。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-9.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>其实这个方法就是用for循环轮询解决CAS丢失和重入失败的问题，具体代码不细过了，有兴趣可以自己找源码看看。</p><h2 id="tryRelease-独占锁（写锁）释放"><a href="#tryRelease-独占锁（写锁）释放" class="headerlink" title="tryRelease() 独占锁（写锁）释放"></a>tryRelease() 独占锁（写锁）释放</h2><p><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-10.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这里又有Condition的踪迹了，大概可以才行到Condition时控制锁的行为的，取消唤醒等操作。<br>另外锁会同时释放读锁和写锁。<br>这个方法比较好理解的，只要是当前线程操作下，持有重入数减去释放数为0就可以释放了，否则失败。</p><h2 id="tryReleaseShared-共享锁（读锁）释放"><a href="#tryReleaseShared-共享锁（读锁）释放" class="headerlink" title="tryReleaseShared() 共享锁（读锁）释放"></a>tryReleaseShared() 共享锁（读锁）释放</h2><p><img src="http://qiniu.zackku.com/image/java-thread-reentrantreadwritelock/readwritelock-11.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>释放读锁，对正在读的线程不会有什么影响，但可以让等待的写线程去开始获取写锁。<br>剩余的内容就是对tryAquireShared()计算的count数值进行释放（自减），如果最终自减为0则释放读锁成功。</p><h1 id="WriteLock、ReadLock内部类"><a href="#WriteLock、ReadLock内部类" class="headerlink" title="WriteLock、ReadLock内部类"></a>WriteLock、ReadLock内部类</h1><p>前面说到ReentrantReadWriteLock的lock()、unlock()操作是分配到Write/ReadLock里面执行的。<br>他们都是Lock接口的实现，所以其实最像ReentrantLock应该是这个两个内部类。而且大体上也没什么差异，也是用Sync的内部类。<br>WriteLock、ReadLock最大的不同就是WriteLock用的独占模式的方法，ReadLock用的是共享模式的方法。<br>具体的代码实现基本就是上面说明的组成，下面介绍下ReentranReadWriteLock的使用。<br>ReentrantLock的时候比较简单，声明一个变量，调用lock()方法即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock rl = new ReentrantLock();</span><br><span class="line">rl.lock();</span><br><span class="line">rl.unlock();</span><br></pre></td></tr></table></figure></p><p>但ReentranReadWriteLock并不是Lock接口的实现，所以没有这些方法。<br>有的只是writeLock()、readLock()，要先调用这个方法获取应对的锁对象，再调用lock()。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();</span><br><span class="line">rwl.readLock().lock();</span><br><span class="line">rwl.readLock().unlock();</span><br><span class="line">rwl.writeLock().lock();</span><br><span class="line">rwl.writeLock().unlock();</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下要点</p><ol><li>读写锁ReentrantReadWriteLock，是基于多读少写的实际场景，提高并发性</li><li>读写锁的Sync添加了共享模式的方法</li><li>读写锁内置了两个对象readLock、writeLock，用于实际的加锁解锁</li><li>写锁是独占的，不允许其他锁的申请</li><li>读锁可以并发重复申请，当有写锁的时候，会发生<strong>锁升级</strong></li></ol><p>特别地，在此祝福8月27日生日的她。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-reentranreedwritelock/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程——ReentrantLock源码阅读</title>
      <link>http://zackku.com/java-thread-reentrantlock/</link>
      <guid>http://zackku.com/java-thread-reentrantlock/</guid>
      <pubDate>Sun, 26 Aug 2018 13:37:05 GMT</pubDate>
      <description>
      
        &lt;p&gt;上一章&lt;a href=&quot;/java-thread-aqs&quot;&gt;《AQS源码阅读》&lt;/a&gt;讲了AQS框架，这次讲讲它的应用类（注意不是子类实现，待会细讲）。&lt;br&gt;ReentrantLock，顾名思义重入锁，但什么是重入，这个锁到底是怎样的，我们来看看类的注解说明&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-thread-reentrantlock/annotion-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;&lt;br&gt;ReentrantLock与隐式锁synchronized功能相同，但ReentrantLock更具有扩展性。&lt;br&gt;&lt;a href=&quot;/java-thread-lock-base&quot;&gt;《锁优化》&lt;/a&gt;里提到Java在1.6对隐式锁synchronized做了锁的优化，使其性能与显式锁性能相差无异。所以在两者的选择上，更多的是考虑用法，以及功能上的扩展。
      
      </description>
      
      <content:encoded><![CDATA[<p>上一章<a href="/java-thread-aqs">《AQS源码阅读》</a>讲了AQS框架，这次讲讲它的应用类（注意不是子类实现，待会细讲）。<br>ReentrantLock，顾名思义重入锁，但什么是重入，这个锁到底是怎样的，我们来看看类的注解说明<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/annotion-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>ReentrantLock与隐式锁synchronized功能相同，但ReentrantLock更具有扩展性。<br><a href="/java-thread-lock-base">《锁优化》</a>里提到Java在1.6对隐式锁synchronized做了锁的优化，使其性能与显式锁性能相差无异。所以在两者的选择上，更多的是考虑用法，以及功能上的扩展。<a id="more"></a><br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/annotion-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>ReentrantLock是线程独占的，不能与其他线程共享。所谓的重入，就是当本线程想再次获得锁，不需要重新申请，它本身就已经锁了，即重入该锁。<br>为什么会允许锁重入呢？因为该线程已经拥有锁了，不会受其他线程干扰，那么里面的共享变量就不会因为多线程执行造成线程不安全。相当于代码已经在串行执行了，没必要再申请多余的锁了，而是重入当前的锁。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/annotion-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>ReentrantLock会提供一个公平锁的模式，如果选择这个模式，会尽量使得获取锁是公平的，先来先得，但不一定严格按顺序。<br>如果选择了公平锁，性能上会比不使用（默认）低一些。没有一定保证顺序，同时也降性能，所以如果没有特别的要求，尽量使用默认的非公平锁。<br>现在基于以上的认识，来看看ReentrantLock的基本实现吧。</p><h1 id="ReentrantLock概览"><a href="#ReentrantLock概览" class="headerlink" title="ReentrantLock概览"></a>ReentrantLock概览</h1><p>ReentrantLock是实现Lock接口的。所以主要的方法就是Lock接口定义的方法，包括lock()、tryLock()、unlock()、newCondition()等。<br>lock()与tryLock()的区别就是前者会一直等到直到获取锁，后者则是尝试在当时获取锁，不会重复去申请获取。<br>这个newCondition()感觉比较突兀，看起来完全不了解有什么用，和Lock有什么关系，我们后面再详细了解。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/lock-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>ReentrantLock里面有一个最核心的成员变量，sync。sync的类型就是内部类Sync。它是AQS的子类，也就是说它就是实现ReentrantLock同步的工具。而FairSync和unFairSync则是Sync的子类，封装了是否公平的功能，用于赋值给sync成员变量。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/lock-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h1 id="Sync同步器"><a href="#Sync同步器" class="headerlink" title="Sync同步器"></a>Sync同步器</h1><p>Sync是继承上文所介绍的AQS，是ReentrantLock里面的NonfairSync和FairSync的父类。<br>看注解可以知道，Sync用了AQS的state（状态原子值）来标识锁被持有的数量。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>在AQS中，tryRelease()是没有定义的，所以在Sync中重写了。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>先判断下申请解锁的线程是否独占锁的线程，否则抛出异常退出。<br>然计算新的state值，用当前state减去releases值。对于state值和releases值到底是多少，这里可以先留个悬念，但大家可以思考下上面注解的定义也可以大概猜出来。<br>最后判断新state值是否为0，为0则没有线程占用，所以设当前独占线程为空，并且更新state。这里更新state值并不需要用CAS原子操作，因为只有一个线程会占用这个锁，不是这个线程都异常退出了。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>AQS中核心的tryAcquire()方法并没有在这里实现，因为子类NonfaiSync和FairSync的实现并不一样。但这里同样需要用到nonfairTryAcquire，所以抽象出来了。但为什么同样需要，暂时不得而知，带着问题后面再看看。<br>先判断当前锁的state是否为0，为0则表示没人获取，然后通过CAS更新为acquires值（依然不知道值是多少），同时更新当前线程为锁的独占线程。<br>如果state不为0，则表示有线程已经占有了。但可能占有的线程是当前线程，那么当前的state会加上acquires值。<br><strong>这里很容易就看出来state就是代表重入的次数！</strong>所以上面的谜题就解开了，releases,aquires都是代表每次申请的值，在ReentrantLock肯定都是1，他们的计算总值就是原子值state。<br>如果state不为0，也不是被当前线程占用，那么返回false获取失败。</p><h2 id="NonfairSync"><a href="#NonfairSync" class="headerlink" title="NonfairSync"></a>NonfairSync</h2><p>没啥特别的，直接调用Sync的方法。也没做修改。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="FairSync"><a href="#FairSync" class="headerlink" title="FairSync"></a>FairSync</h2><p>公平锁的同步器。只有当递归调用或者没有其他等待者，再或者他自己本身排第一才能获取锁。<br>这话比较绕口，大概意思应该是不停地轮询申请锁，直到自己排到队列的第一才能获取。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>乍看一看，这个方法基本和父类Sync的nonfairTryAcquire()一样，唯一不同点就是在没有线程占用的时候（state=0），多了个<code>!hasQueuedPredecessors()</code>前置判断。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/sync-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个方法用来判断是否队列为空，或者当前线程是否在队列的最前面。<br>所以公平锁模式下，想要能获取锁，除非自己排在队列的最前面。<br>综上看，FairSync根本没有调用到nonfairTryAcquire()，为何说子类都需要用到呢？继续留着悬念，后面解答。</p><h2 id="ReservedStackAccess"><a href="#ReservedStackAccess" class="headerlink" title="@ReservedStackAccess"></a>@ReservedStackAccess</h2><p>可以看到上面介绍的tryAcquire()和tryRelease()都有@ReservedStackAccess。这个注解到底有什么用？<br>查找了下资料，这个是JEP 270添加的新注解。它会保护被注解的方法，通过添加一些额外的空间，防止在多线程运行的时候出现栈溢出。具体看下图<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/reserverd-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h1 id="lock-、tryLock-成员函数"><a href="#lock-、tryLock-成员函数" class="headerlink" title="lock()、tryLock()成员函数"></a>lock()、tryLock()成员函数</h1><p>ReentrantLock里面的lock()方法是调用成员变量sync的acquire()。<br>无论是否公平锁都是直接调用AQS的acquire()方法，不过就是各自有tryAcuqire()的重写，即上文所说的内容。<br>参数1，是透传给tryAcquire()的，所以这里代表是入锁一次的意思。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/lock-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>而tryLock()调用的是成员变量sync的nonfairTryAcquire()。上文说到Sync内部类抽象了这个方法出来，说到子类都会用到，说的正是tryLock()方法需要用到。<br>所以显而易见的，无论是否公平锁，调用tryLock()都是用的非公平锁的方法。为什么呢？<br>因为tryLock()的try只是尝试，无论是否公平，对于方法来说没有必要，只是尝试申请的时候能否获取锁而已。<br><img src="http://qiniu.zackku.com/image/java-thread-reentrantlock/lock-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>至于其他成员函数，大都是围绕获取线程和队列的状态，没什么特别的，在这里不再赘述，有兴趣的可以看看源码。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下要点</p><ol><li>ReentrantLock是一个可重入的锁（被当前占用的线程重入）。</li><li>它有两种模式公平与非公平，通过NonfairSync和FairSync赋值sync成员变量实现。</li><li>两种模式都是AQS的子类，通过重写tryAcquire()区别不同。公平锁多了是否在队列的头的判断。</li><li>tryLock()方法没有区分模式，都是一样的。</li></ol><p>上文提到的newCondition()还没有涉及到，等后续再起一章节说下这个Condition。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-reentrantlock/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程——AQS框架源码阅读</title>
      <link>http://zackku.com/java-thread-aqs/</link>
      <guid>http://zackku.com/java-thread-aqs/</guid>
      <pubDate>Wed, 22 Aug 2018 03:10:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;AQS，全称&lt;code&gt;AbstractQueuedSynchronizer&lt;/code&gt;，是Concurrent包锁的核心，没有AQS就没有Java的Concurrent包。它到底是个什么，我们来看看源码的第一段注解是怎么说明&lt;br&gt;&lt;img src=&quot;http://qiniu.zackku.com/image/java-thread-aqs/annotation-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim&quot; alt=&quot;&quot;&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>AQS，全称<code>AbstractQueuedSynchronizer</code>，是Concurrent包锁的核心，没有AQS就没有Java的Concurrent包。它到底是个什么，我们来看看源码的第一段注解是怎么说明<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/annotation-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><a id="more"></a><br><img src="http://qiniu.zackku.com/image/java-thread-aqs/annotation-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><img src="http://qiniu.zackku.com/image/java-thread-aqs/annotation-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>看完第一段，总结下</p><ul><li>AQS是一个同步的基础框架，基于一个先进先出的队列。</li><li>锁机制基于一个状态值，它是原子值。</li><li>AQS的子类负责定义与操作这个状态值，但必须通过AQS提供的原子操作</li><li>AQS剩余的方法就是围绕队列，与线程阻塞唤醒等功能</li></ul><p>基于以上概念，我们看看源码到底是这么实现这些功能的</p><h1 id="AQS的成员变量"><a href="#AQS的成员变量" class="headerlink" title="AQS的成员变量"></a>AQS的成员变量</h1><p><img src="http://qiniu.zackku.com/image/java-thread-aqs/properties-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p><code>private volatile int state;</code><br>该变量标记为<code>volatile</code>，说明该变量是对所有线程可见的。作用在于每个线程改变该值，都会马上让其他线程可见，在CAS（可见<a href="/java-thread-lock-base/">锁概念与锁优化</a>）的时候是必不可少的。在AQS类中，不会直接操作这个值，而是交由它的子类去操作和定义他的作用。</p><h2 id="Node、head、tail"><a href="#Node、head、tail" class="headerlink" title="Node、head、tail"></a>Node、head、tail</h2><p>AQS中有一个静态内部类<code>Node</code>，其实现是一个双向链表。<code>head</code>与<code>tail</code>则是这个链表的头尾指针。作用是存储获取锁失败的阻塞线程。同样的，这个链表是会被多个线程操作的，所以它里面的变量多是被标记为<code>volatile</code>，并且操作也要通过CAS等原子方法去执行。<br>Node还有一个模式的属性：<strong>独占模式</strong>和<strong>共享模式</strong>。独占模式下，锁是线程独占的，而共享模式下，锁是可以被多个线程占用的。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/properties-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="VarHandler"><a href="#VarHandler" class="headerlink" title="VarHandler"></a>VarHandler</h2><p>对于大多数需要操作的原子属性，都对应会有一个大写的值，它的类是<code>VarHandler</code>。例如<code>state、head、tail</code>都有对应的VarHandler，<code>STATE、HEAD、TAIL</code>。VarHandler是<code>1.9</code>的新特性，提供了类似于原子操作以及Unsafe操作的功能，里面的原子操作大多是native方法，比较难查看源码。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/properties-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="ConditionObject"><a href="#ConditionObject" class="headerlink" title="ConditionObject"></a>ConditionObject</h2><p>条件队列，是AQS中一个非常关键内部类。这个名字起非常奇异，让人搞不懂，看它类注释也看不懂说了什么。看看AQS头部注解<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/annotation-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>这个类是为了让子类支持独占模式的。深入看其中的源码实现，其实就是Node在功能性上的封装，最终让子类实现让当前线程怎么独占一个Object锁。<code>await()、dosign()</code>等方法就是让线程阻塞、加入队列、唤醒线程等。AQS框架下基本各种独占的加锁，解锁等操作到最后都是基于这个类实现的。该类是提供给子类去使用的，具体实现等下次说<code>ReentranLock</code>再深入了解。有人可能觉得为什么实现这个内部类，又不用，而是给子类去用，那为什么不放到子类去呢？其实答案，很简单，<strong>抽象加模板模式</strong>。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/properties-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>p.s. 只有独占锁才能配合该类使用。</p><h1 id="AQS的成员函数"><a href="#AQS的成员函数" class="headerlink" title="AQS的成员函数"></a>AQS的成员函数</h1><p>AQS的公用的方法，主要是加锁与解锁方法。以下方法只提供了模板，部分实现还是在子类当中，直接调用会抛出异常。</p><h2 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h2><p>尝试获取锁，失败则进入队列。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>先执行<code>tryAcquire()</code>（子类实现），成功则直接返回，如果是获取锁失败，则执行<code>addWaiter()</code>，通过CAS在双向链表的尾部添加一个新独占节点。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>然后把节点丢到<code>acquireQueued()</code>中执行。该方法其实就是自旋尝试获取锁或阻塞线程（子类实现决定）。一开始，获取新节点的前驱节点，如果这个节点是head，则证明只有两个节点，此时再次执行<code>tryAcquire()</code>尝试获取锁，若获取成功，则不需要中断，成功结束。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-4.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>如果还是获取失败，则执行<code>shouldParkAfterFailedAcquire()</code>，根据前驱节点状态（子类设值）判断是否继续自旋（当waitStatus为初始值，重复上一步，直到前面的节点一直在减少到前驱节点为head）或者阻塞线程（当waitStatus标记为SIGNAL）<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-5.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>最后如果<code>acquireQueued()</code>返回需要阻塞，则执行<code>selfInterrupt()</code>设置线程为中断<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-3.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>可以看回<code>acquire()</code>函数的写法，十分的艺术。利用条件判断的短路规则，实现在<code>if()</code>条件内嵌套判断执行语音。一般人(笔者本人)如果要实现这个功能，会这么写</p><p><img src="http://qiniu.zackku.com/image/java-thread-aqs/code-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><p>所以下次遇到类似嵌套if条件判断的语句，可以学习下<code>acquire()</code>的这种短路写法。赞👍</p><h2 id="acquireInterruptibly"><a href="#acquireInterruptibly" class="headerlink" title="acquireInterruptibly()"></a>acquireInterruptibly()</h2><p>检查线程是否被中断并尝试获取锁，失败则进入队列。线程中断会退出队列。<br>流程基本和<code>acquire()</code>相同。不同点就是，<code>acquireInterruptibly()</code>在自旋获取过程中如果线程是中断的，那么就会抛出异常退出流程，并且放弃锁。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-6.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br><code>doAcquireInterruptibly()</code>方法与<code>acquireQueued()</code>方法非常相似，不同就是前者在中断状态下，不会再继续获取锁。注意最后有<code>cancelAcquire()</code>方法的执行。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-7.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="tryAcquireNanos"><a href="#tryAcquireNanos" class="headerlink" title="tryAcquireNanos()"></a>tryAcquireNanos()</h2><p>尝试获取锁，失败则进入队列。当超过指定时间或线程中断会退出队列。<br>在<code>acquireInterruptibly()</code>基础上，增加多一个时间判断，超过指定时间，则退出，放弃获取锁。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/acquire-8.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h2><p>释放当前锁，并唤醒下一个Node。<br>尝试释放锁<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/release-1.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""><br>若释放成功，且waitStatus不为0（证明是SIGNAL的），就会执行<code>unparkSuccessor()</code>，先取消SIGNAL标志，然后找到最近一个需要SIGNAL的节点，并且唤醒它。<br><img src="http://qiniu.zackku.com/image/java-thread-aqs/release-2.png?imageMogr2/auto-orient/blur/1x0/quality/75|watermark/2/text/WmFja-ivtOeggQ==/font/5b6u6L2v6ZuF6buR/fontsize/400/fill/I0Y2RjZGNg==/dissolve/60/gravity/SouthEast/dx/10/dy/10|imageslim" alt=""></p><h2 id="shared"><a href="#shared" class="headerlink" title="**shared()"></a>**shared()</h2><p>以上方法皆为独占模式，对应都有共享模式的方法。最大的不同其实就是Node的waitStatus值为PROPAGATE。具体流程与独占大体相同，细节留到<code>ReentrantReadWriteLock</code>再细了解。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>回顾下要点</p><ol><li>AQS是一个同步的基础框架，是ReentranLock、ReentranReadWriteLock的父类</li><li>AQS原理是维护一个state原子值，通过一个双向链表的队列实现同步。</li><li>对于state、与队列的操作都是原子操作，通过VarHandle实现</li><li>主要对外方法是加锁与解锁，区别是否中断、超时、共享或独占模式</li></ol><p>以上即使AQS的大致内容，可能有些部分难以理解，其实很正常，因为AQS提供的是流程模板与工具，没有实质落地的场景，是比较难理解的。等后面介绍<code>ReentranLock</code>与<code>ReentrantReadWriteLock</code>的时候，就可以更好更全面的了解整体AQS框架了。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br><img src="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" alt=""></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-aqs/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程——锁概念与锁优化</title>
      <link>http://zackku.com/java-thread-lock-base/</link>
      <guid>http://zackku.com/java-thread-lock-base/</guid>
      <pubDate>Wed, 08 Aug 2018 02:17:30 GMT</pubDate>
      <description>
      
        &lt;p&gt;为了性能与使用的场景，Java实现锁的方式有非常多。而关于锁主要的实现包含&lt;strong&gt;synchronized关键字&lt;/strong&gt;、&lt;strong&gt;AQS框架下的锁&lt;/strong&gt;，其中的实现都离不开以下的策略。&lt;/p&gt;
&lt;h2 id=&quot;悲观锁与乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁与乐观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁与乐观锁&quot;&gt;&lt;/a&gt;悲观锁与乐观锁&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;乐观锁&lt;/strong&gt;。乐观的想法，认为并发读多写少。每次操作的时候都不上锁，直到更新的时候才通过CAS判断更新。对于&lt;strong&gt;AQS框架下的锁&lt;/strong&gt;，初始就是乐观锁，若CAS失败则转化为悲观锁。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;悲观锁&lt;/strong&gt;。悲观的想法，认为并发写多读少。每次操作数据都上锁，即使别人想读也要先获得锁才能读。对于1.6以前的&lt;strong&gt;synchronized关键字&lt;/strong&gt;，则是悲观锁的实现之一。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;CAS无锁算法&quot;&gt;&lt;a href=&quot;#CAS无锁算法&quot; class=&quot;headerlink&quot; title=&quot;CAS无锁算法&quot;&gt;&lt;/a&gt;CAS无锁算法&lt;/h2&gt;&lt;p&gt;全称为 Compare and Swap。CAS有三个操作数，内存值V，旧预期值（已获得的旧数据）A，修改新值B。当且仅当V与A的值相同（compare），才能把V替换为B（Swap）。其中Java中内存值可以通过&lt;strong&gt;volatile关键字&lt;/strong&gt;标识获取，该关键词可以使变量对所有线程实时可见。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>为了性能与使用的场景，Java实现锁的方式有非常多。而关于锁主要的实现包含<strong>synchronized关键字</strong>、<strong>AQS框架下的锁</strong>，其中的实现都离不开以下的策略。</p><h2 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h2><ul><li><strong>乐观锁</strong>。乐观的想法，认为并发读多写少。每次操作的时候都不上锁，直到更新的时候才通过CAS判断更新。对于<strong>AQS框架下的锁</strong>，初始就是乐观锁，若CAS失败则转化为悲观锁。</li><li><strong>悲观锁</strong>。悲观的想法，认为并发写多读少。每次操作数据都上锁，即使别人想读也要先获得锁才能读。对于1.6以前的<strong>synchronized关键字</strong>，则是悲观锁的实现之一。</li></ul><h2 id="CAS无锁算法"><a href="#CAS无锁算法" class="headerlink" title="CAS无锁算法"></a>CAS无锁算法</h2><p>全称为 Compare and Swap。CAS有三个操作数，内存值V，旧预期值（已获得的旧数据）A，修改新值B。当且仅当V与A的值相同（compare），才能把V替换为B（Swap）。其中Java中内存值可以通过<strong>volatile关键字</strong>标识获取，该关键词可以使变量对所有线程实时可见。<br><a id="more"></a><br>CAS算法在锁的应用非常广泛，java中concurrent包的高性能都是基于这个算法，可以说没有CAS，并发包的高性能也就不存在了。</p><h2 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h2><p>悲观锁的一种。互斥使代码执行可以同步，但这种方式成本比较高，涉及到操作系统的调用阻塞，会造成一些系统资源的浪费。1.6以前，在Java中的即是监视器锁，把.java文件编程成.class文件后能看到<strong>synchronized关键字</strong>就是通过monitorenter和monitorexit这个两个字节码指令来实现的。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>由于在没有很多线程竞争的前提下，重量级锁会导致性能资源的浪费。每次判断是否无锁，无锁则建锁记录，有锁通过CAS去尝试获取锁（对比Mark Word）。该过程失败会让锁膨胀为重量级锁。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>是轻量级锁的优化，适用于无多线程竞争。虽然轻量级锁在可以在较少线程竞争下，减少操作系统调用，减少互斥变量的产生。但在理想情况下，线程很少发生线程竞争，在轻量级锁中，还是会有比较多的CAS操作。在偏向锁中，有一个锁记录（Mark word）标记为偏向，指向当前线程。若该指向不变，则只需要判断记录是否有被切换。如果被切换了，尝试CAS替换指向，后续一直执行同步代码块。当CAS替换指向失败，则说明存在多线程竞争，此时锁会膨胀为轻量级锁。</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>是锁竞争失败后执行的策略之一，对应的有阻塞的锁。在线程竞争锁失败后，阻塞的锁会把线程阻塞，直到有信号唤起才能继续执行线程，此过程会涉及用户态与系统态的转换，产生性能消耗。而自旋锁在锁竞争失败后，会把线程做自旋，避免线程进入阻塞。在自旋过程中，会不断的尝试去竞争锁。<br>但如果线程一直自旋都获取不到锁，也会产生很多CPU的性能消耗，所以也有一个<strong>自适应的自旋锁</strong>（控制自旋的时间）解决这个问题。</p><hr><p>更多技术文章、精彩干货，请关注<br>博客：zackku.com<br>微信公众号：Zack说码<br>![](<a href="http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png" target="_blank" rel="noopener">http://qiniu.zackku.com/%E6%89%AB%E7%A0%81_%E6%90%9C%E7%B4%A2%E8%81%94%E5%90%88%E4%BC%A0%E6%92%AD%E6%A0%B7%E5%BC%8F-%E5%BE%AE%E4%BF%A1%E6%A0%87%E5%87%86%E7%BB%BF%E7%89%88.png</a></p>]]></content:encoded>
      
      <comments>http://zackku.com/java-thread-lock-base/#disqus_thread</comments>
    </item>
    
    <item>
      <title>JVM学习记录——GC对象搜索算法</title>
      <link>http://zackku.com/jvm-gc-object-search/</link>
      <guid>http://zackku.com/jvm-gc-object-search/</guid>
      <pubDate>Wed, 30 May 2018 07:42:44 GMT</pubDate>
      <description>
      
        &lt;p&gt;Java与C最大的区别或许就是Java拥有垃圾回收（Garbage Collect）功能，可以让开发人员无需过多关心程序中的对象内存如何管理，更专注于业务的开发。但是如果不好好了解GC，也遇到性能瓶颈时很难容易的解决。&lt;/p&gt;
&lt;p&gt;GC回收的对象是无用的对象，狭义是没有被引用的对象。如何在内存中找到这些对象，一般有以下两种&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Java与C最大的区别或许就是Java拥有垃圾回收（Garbage Collect）功能，可以让开发人员无需过多关心程序中的对象内存如何管理，更专注于业务的开发。但是如果不好好了解GC，也遇到性能瓶颈时很难容易的解决。</p><p>GC回收的对象是无用的对象，狭义是没有被引用的对象。如何在内存中找到这些对象，一般有以下两种<br><a id="more"></a></p><h2 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h2><p>这个算法非常简单。给对象一个计数器，每当这个对象被引用了，计数器值加一；引用失效，则减一。但这个对象计数值为0的时候，证明是无用对象，可以被GC程序回收掉。这种算法比较广泛应用在一些脚本语言上，如FLASH、PYTHON等。<br>但是引用计数算法无法解决对象间相互引用的问题。当a对象引用了b对象，b对象也引用了a对象，这样a、b两个对象的计数器值都不会为0，即使这两个对象都被其他对象所引用，最终导致这些对象一直无法被回收。这种情况往往会出现在比较复杂的编程语言中。</p><h2 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h2><p>可达性分析算法（GC roots算法），广泛应用于主流的商用语言。设置一个根节点，从图论角度来看，只要从该节点可达一个对象，证明这个对象是存活的（被引用）。<br><img src="/images/jvm-gc-roots/gc-roots.jpeg" alt=""><br>通常地，GC会包含以下区域的对象：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象；</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《深入理解Java虚拟机——JVM高级特性与最佳实践》—— 3.2</p>]]></content:encoded>
      
      <comments>http://zackku.com/jvm-gc-object-search/#disqus_thread</comments>
    </item>
    
    <item>
      <title>Spring AOP Transactional注解不能用于内部调用问题</title>
      <link>http://zackku.com/spring-transaction-in-class-problem/</link>
      <guid>http://zackku.com/spring-transaction-in-class-problem/</guid>
      <pubDate>Fri, 25 May 2018 08:18:53 GMT</pubDate>
      <description>
      
        &lt;p&gt;Spring框架中的Transactional注解是几个比较常用注解之一，作用就是用于事务的管理。如果系统接的Mybatis的数据库，那么Spring的Transactional就会接替sqlSession的生命周期管理。&lt;br&gt;它的用法非常简单，就是把它标注在需要事务的方法上面即可。例如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;@Transactional(rollbackFor = Exception.class)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;public void createBidOffer() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    insertBidAndOffer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是并不是放到任何方法上，它都会生效的。&lt;br&gt;
      
      </description>
      
      <content:encoded><![CDATA[<p>Spring框架中的Transactional注解是几个比较常用注解之一，作用就是用于事务的管理。如果系统接的Mybatis的数据库，那么Spring的Transactional就会接替sqlSession的生命周期管理。<br>它的用法非常简单，就是把它标注在需要事务的方法上面即可。例如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void createBidOffer() &#123;</span><br><span class="line">    insertBidAndOffer();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是并不是放到任何方法上，它都会生效的。<br><a id="more"></a></p><h2 id="类中方法调用"><a href="#类中方法调用" class="headerlink" title="类中方法调用"></a>类中方法调用</h2><p>一个例子，有如下调用逻辑：<br><strong>controller部分代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;/transaction&quot;)</span><br><span class="line">public Response testTransactionAop() &#123;</span><br><span class="line">    tradeService.createBidOffer();</span><br><span class="line">    return new Response();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>TradeService部分代码</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void createBidOffer() &#123;</span><br><span class="line">    ....</span><br><span class="line">    insertBidAndOffer();</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">public void insertBidAndOffer() &#123;</span><br><span class="line">    insertBid();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Bid insertBid() &#123;</span><br><span class="line">    Bid bid = new Bid();</span><br><span class="line">    bid.setTotalAmount(100);</span><br><span class="line">    bid.setRestAmount(100);</span><br><span class="line">    bidMapper.insert(bid);</span><br><span class="line">    return bid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>TradeService的对外接口是createBidOffer()，但不想整个方法做事务，只对于insertBidAndOffer()里面的操作做事务。<br>可惜的是以上这种写法是无效的。虽然执行时候不会有任何报错异常，但一旦insertBidAndOffer()方法执行过程中抛出异常，事务是不会生效的，<strong>即使方法是public也没用</strong>（Transaction注解要求作用于public的方法上）。</p><h2 id="Transactional-的AOP切点"><a href="#Transactional-的AOP切点" class="headerlink" title="@Transactional 的AOP切点"></a>@Transactional 的AOP切点</h2><p><strong>Spring AOP其实是与IOC配合使用的，而Spring AOP是用动态代理的技术。也就是说一个类被IOC所注入生成的对象被Spring动态代理成一个新的代理对象。</strong><br><strong>无效的原因其实就很容易理解了，我们在外部调用这个动态代理对象，会在代理的时候增强对象，但在对象的内部调用的时候，调用的还是原来的对象的方法，该方法明细不会被AOP增强</strong>。上面的例子，在Spring框架里，TradeService注入到controller中，生成一个代理的tradeService对象，在controller调用tradeService方法的时候，被代理的方法拦截。该方法中会找出这个AOP连接点的Advice，然后切入执行（也就是执行@Transactional）。若是调用对象内容方法的时候，就不会被代理发放拦截的了。<br>下图即为拦截切入点，框内为切入后执行该切点的Advice，事务就在其中执行<br><img src="/images/spring-transaction/CglibAopProxy-intercept.jpeg" alt=""><br><strong>P.S. 如果该类实现了接口，Java的Proxy做动态代理；如果没有实现，则是CGLIB做的动态代理（以子类的方式）。</strong></p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>一个原则：事务注解只用于对外的方法上。<br>如果想实现对象内部调用的逻辑，最简单的方法就是，把逻辑抽出来，放到另外一个类中取调用即可。</p><h2 id="源码参考"><a href="#源码参考" class="headerlink" title="源码参考"></a>源码参考</h2><p>Java web 项目脚手架： <a href="https://github.com/Zack-Ku/java-web-scaffold" target="_blank" rel="noopener">https://github.com/Zack-Ku/java-web-scaffold</a></p>]]></content:encoded>
      
      <comments>http://zackku.com/spring-transaction-in-class-problem/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
